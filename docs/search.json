[
  {
    "objectID": "TP1-InitR.html",
    "href": "TP1-InitR.html",
    "title": "TP 1 : Introduction au langage R",
    "section": "",
    "text": "Objectif\nLes objectifs de cette séance sont\nCe TP s’appuie sur des parties du tutoriel R disponible sur https://cmaugis.github.io/TutorielR-V2025/."
  },
  {
    "objectID": "TP1-InitR.html#pourquoi-r",
    "href": "TP1-InitR.html#pourquoi-r",
    "title": "TP 1 : Introduction au langage R",
    "section": "1.1 Pourquoi R ?",
    "text": "1.1 Pourquoi R ?\nLe logiciel R sous licence GNU est facile à installer à partir de la page du CRAN (ou d’un site miroir). Le CRAN contient toutes les ressources nécessaires à l’utilisateur de R, débutant ou expérimenté : fichiers d’installation, mises à jour, librairies, FAQ, newsletter, documentation… R est un logiciel très utilisé dans la communauté statistique.\nDans sa structure, R est un langage de programmation d’une syntaxe voisine à celle du langage C et capable de manipuler des objets complexes sous forme de matrice, scalaire, vecteur, liste, facteur et aussi data frame. Il dispose également d’une très riche librairie de quasiment toutes les procédures et méthodes statistiques de la littérature."
  },
  {
    "objectID": "TP1-InitR.html#présentation-de-rstudio",
    "href": "TP1-InitR.html#présentation-de-rstudio",
    "title": "TP 1 : Introduction au langage R",
    "section": "1.2 Présentation de Rstudio",
    "text": "1.2 Présentation de Rstudio\nNous allons utiliser RStudio durant les TP d’Analyse de Données et d’Elements de modélisation statistique. RStudio n’est pas qu’une interface graphique pour R, il s’agit d’un environnement de développement intégré, proposant des outils et facilite l’écriture de scripts et l’utilisation de R. La version gratuite de RStudio étant déjà très riche en fonctionnalités, elle est suffisante pour les enseignements. Elle est disponible pour Linux, Windows et MacOS.\nAprès avoir installé une version récente du logiciel R (voir CRAN), installez la version gratuite de Rstudio adaptée à votre OS.\n\n1.2.1 Description des fenêtres de RStudio\nA chaque ouverture de RStudio, l’écran est découpé en quatre grandes zones :\n\nEn bas à gauche c’est la Console, on peut y lire au lancement la version de R que RStudio a chargé. Après le texte d’entrée, la ligne commence par &gt; qui est l’invite de commande. RStudio est prêt à recevoir votre première commande. On peut se servir de R comme d’une calculatrice. Vous pouvez par exemple taper &gt; 2+3 et taper Entrée. Le résultat apparait alors dans la console.\nEn haut à droite, on peut voir dans Environnement la liste des objets et fonctions créés au fur et à mesure du travail. On a également accès à l’historique des commandes dans History.\nEn bas à droite, on trouve plusieurs onglets :\n\nFiles : permet de voir le contenu du répertoire de travail\nPlots : permet de visualiser les graphiques créés\nPackages : liste les packages installés pour les charger, mettre à jour, en installer d’autres\nHelp : permet d’accéder à l’aide en ligne\n\nEn haut à gauche, c’est la zone d’Edition pour gérer les scripts, les executer, ….\n\nLorsque vous quittez RStudio, on vous demande si vous souhaitez sauvegarder l’environnement de travail. Si vous y répondez favorablement, un fichier de sauvegarde .RData est enregistré dans le répertoire courant.\n\n\n1.2.2 Types de documents avec RStudio\nEn allant dans File -&gt; New File ou en cliquant sur la flèche à côté de l’icone de New File (en haut à gauche), RStudio propose de nombreux types de document. Vous pouvez noter que l’on peut utiliser RStudio également pour faire du python, du C++, … Nous allons ici ne parler que de quelques types de fichiers que l’on utilisera par la suite.\nPour créer un script R, il suffit de sélectionner R Script. Ce script peut être enregistré à tout moment dans un fichier avec l’extension ” .R” (ex. monScript.R) dans le répertoire courant en cliquant sur l’icône de disquette ou par File-&gt;Save. Vous pouvez l’ouvrir à tout moment grâce au menu File –&gt; Open file..., à l’icône dossier ou en double cliquant sur le fichier monScript.R. Il est également possible d’executer un script directement depuis la console grâce à la commande source(\"monScript.R\").\nOn peut également créer des documents de type rapport, slides, … contenant du texte, du code, des images, des formules mathématiques en latex, ….\n\nà l’aide de RMarkdown en sélectionnant R markdown .... Le document créé sera sauvegardé avec l’extension ” .Rmd”.\n\nPour plus de détails, voir ici.\n\nà l’aide de quarto en sélectionnant Quarto Document ... ou Quarto Presentation ... pour la création de présentation, rapports, … La syntaxe est assez proche de celle de Rmarkdown. Dans la suite du cours, on travaillera avec des fichiers quarto.\n\nPour plus de détails, voir ici."
  },
  {
    "objectID": "TP1-InitR.html#environnement",
    "href": "TP1-InitR.html#environnement",
    "title": "TP 1 : Introduction au langage R",
    "section": "1.3 Environnement",
    "text": "1.3 Environnement\n\n1.3.1 Répertoire de travail\nPour pouvoir récupérer des données, maîtriser la sauvegarde des scripts, des résultats, … il est important de connaitre le répertoire de travail c’est-à-dire le répertoire sous lequel les divers résultats seront sauvegardés par défaut. Ce dernier s’obtient à l’aide de la commande &gt; getwd().\nPour changer de répertoire de travail, on peut\n\nutiliser la commande setwd() dans la Console. A noter que R ne reconnaît que le caractère “/” pour spécifier le chemin d’accès d’un répertoire (même sous Windows).\npasser par Session -&gt; Set Working Directory -&gt; Choose Directory.\n\n\nExercice :\n\n\nCréez un dossier de travail pour ce TP dans votre home (en dehors de RStudio!) Placez dans ce dossier le fichier TP1-InitR.qmd disponible sur moodle. Dans RStudio, placez-vous dans ce dossier de travail pour le TP. Ouvrez le fichier TP1-InitR.qmd. Vous êtes maintenant prêt à poursuivre ce TP.\n\n\n\n1.3.2 Les librairies pour R\nR est un logiciel libre, il s’enrichit grâce au développement de librairies par la communauté. La plupart des extensions sont développées et maintenues par la communauté des utilisateurs de R, et diffusées via le CRAN (Comprehensive R Archive Network). On peut également trouver des packages déposés sur github par exemple.\nPour installer une librairie disponible sur le CRAN, vous avez plusieurs manières de le faire, dont\n\npasser par le menu Tools-&gt; Install Packages ... , sélectionner un site miroir du CRAN et demander la librairie souhaitée\naller dans l’onglet Packages dans la fenêtre en bas à droite et cliquer sur Install.\nutiliser la fonction install.packages() directement dans la console en précisant la librairie souhaitée\n\nToutes les librairies ne sont pas chargées automatiquement au lancement de R. Pour charger une librairie, on utilise la commande library().\n\nExercice :\n\n\n\nInstallez la librairie corrplot\nChargez la librairie corrplot\n\n\n\n\n1.3.3 L’aide de R\nOn peut à tout moment faire appel à l’aide intégrée de R (et surtout avant d’appeler l’enseignant-e !) pour avoir les détails comme les arguments d’une fonction. On peut accéder à l’aide pour une fonction (ex pour la fonction plot) en passant le nom de la fonction dans help() (ex &gt; help(plot)) ou en utilisant le raccourci &gt; ?plot. Ces deux commandes permettent d’afficher une page de description (en anglais) de la fonction, ses paramètres, son résultat, d’exemples, … Dans RStudio, les pages d’aide en ligne s’ouvriront par défaut dans la zone en bas à droite, sous l’onglet Help. Un clic sur l’icône en forme de maison vous affichera la page d’accueil de l’aide. Vous pouvez aussi taper directement le nom de la fonction recherchée dans la zone de recherche dans l’onglet Help.\n\nExercice :\n\n\nAccédez à l’aide de la fonction rnorm"
  },
  {
    "objectID": "TP1-InitR.html#opération-sur-les-scalaires",
    "href": "TP1-InitR.html#opération-sur-les-scalaires",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.1 Opération sur les scalaires",
    "text": "2.1 Opération sur les scalaires\n\nOpérationsis.xxx()/as.xxx()Arrondir\n\n\nLes opérations élémentaires sur les scalaires sont *,-, +, /, ^.\n\nExecutez les commandes suivantes. Vous chercherez en particulier à bien identifier les différents types de données :\n\n2+2\nexp(10)\na = log(2)\na\nb =cos(10)\nb\na - b\na*b\nd &lt;- 2 &lt; 3\nd\ndd &lt;- FALSE\ndd - d\ndd + d\ne&lt;- \"toto\"\nclass(e)\nstr(e)\n\n\n\nPour tester si un objet obj est de type xxx, on utilise la commande is.xxx(obj). On peut aussi contraindre si possible l’objet obj au type xxx avec la commande as.xxx(obj).\n\na = 4.3\nis.numeric(a)\n\n[1] TRUE\n\nis.complex(a)\n\n[1] FALSE\n\nis.character(a)\n\n[1] FALSE\n\nas.character(a)\n\n[1] \"4.3\"\n\nb&lt;- \"toto\"\nis.numeric(b)\n\n[1] FALSE\n\nas.list(b)\n\n[[1]]\n[1] \"toto\"\n\n\n\n\nPour obtenir des valeurs arrondies sur des valeurs numériques, vous pouvez utiliser l’une des commandes suivantes round(), ceiling(), floor(), trunc() ou signif() (voir l’aide ?round). Comparez les codes suivantes:\n\na=1.3579\nfloor(a)\n\n[1] 1\n\nceiling(a)\n\n[1] 2\n\nround(a,digits=2)\n\n[1] 1.36\n\nsignif(a,digits=2)\n\n[1] 1.4\n\nis.integer(floor(a))\n\n[1] FALSE\n\nis.numeric(floor(a))\n\n[1] TRUE"
  },
  {
    "objectID": "TP1-InitR.html#booléens-et-opérations-logiques",
    "href": "TP1-InitR.html#booléens-et-opérations-logiques",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.2 Booléens et opérations logiques",
    "text": "2.2 Booléens et opérations logiques\nEn R, un booléen est représenté par TRUE ou FALSE. Les opérations logiques, &lt;, &gt;, &lt;=, &gt;=, != (différent), == (égal) retournent TRUE ou FALSE. On peut définir plusieurs conditions à remplir avec les opérateurs & (ET) et | (OU).\nAttention, R considère qu’un booléen a FALSE vaut \\(0\\) et qu’un booléen a TRUE vaut \\(1\\). Il est donc capable d’évaluer TRUE + 5 bien qu’en toute logique, cela n’a aucun sens!\nVoici quelques exemples de manipulation des booléens :\n\na &lt;- 3\nb &lt;- 6\na&lt;=b\n\n[1] TRUE\n\na!=b\n\n[1] TRUE\n\n(b-3==a) & (b&gt;=a)\n\n[1] TRUE\n\n(b==a) | (b&gt;=a)\n\n[1] TRUE"
  },
  {
    "objectID": "TP1-InitR.html#les-caractères",
    "href": "TP1-InitR.html#les-caractères",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.3 Les caractères",
    "text": "2.3 Les caractères\nOn donne ici quelques fonctions de base sur la manipulation des chaînes de caractères. Dans le tutoriel, on présente le package stringr qui est très utilisé pour gérer et manipuler des chaînes de caractères (voir ici).\n\npaste()nchar()substr() / substring()strsplit()grep()gsub()\n\n\nPour concaténer, juxtaposer des chaînes de caractères on utilise la fonction paste()\n\nEx &lt;- paste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\")\npaste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\",sep=\"_\")\n\n[1] \"Bonjour_à_toutes_et_tous_!\"\n\nx &lt;- c(\"Bonjour\", \"à\", \"vous\")\npaste(x)\n\n[1] \"Bonjour\" \"à\"       \"vous\"   \n\n\n\n\nOn accède à la longueur d’une chaîne avec la fonction nchar()\n\nEx\n\n[1] \"Bonjour à toutes et tous !\"\n\nnchar(Ex)\n\n[1] 26\n\n\n\n\nLa fonction substr() permet d’extraire une partie d’une chaîne à partir des attributs « start » et « stop ». On peut aussi remplacer des segments d’une chaine.\n\nEx\n\n[1] \"Bonjour à toutes et tous !\"\n\nsubstr(Ex,start=3,stop=9)\n\n[1] \"njour à\"\n\nsubstr(Ex, start = 3, stop = 9) &lt;- \"@@@\"\nEx\n\n[1] \"Bo@@@ur à toutes et tous !\"\n\n\nOn peut aussi utiliser la fonction substring()\n\nEx &lt;- paste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\")\nsubstring(Ex, first = 3)\n\n[1] \"njour à toutes et tous !\"\n\nsubstring(Ex, first = 3, last = 9) &lt;- \"@@@--&lt;\"\nEx\n\n[1] \"Bo@@@--&lt;à toutes et tous !\"\n\n\n\n\nLa fonction strsplit() permet de scinder une chaîne de caractères :\n\nEx &lt;- paste(\"Bonjour\", \"à\",\"toutes\",\"et\",\"tous\",\"!\")\nstrsplit(Ex,split= \" \")\n\n[[1]]\n[1] \"Bonjour\" \"à\"       \"toutes\"  \"et\"      \"tous\"    \"!\"      \n\nstrsplit(Ex,split=c(\"o\",\" \"))\n\n[[1]]\n[1] \"B\"         \"nj\"        \"ur à t\"    \"utes et t\" \"us !\"     \n\n\nLa sortie de la fonction strsplit() est une liste (voir section sur list)\n\n\nLa fonction grep() permet de rechercher les éléments d’une liste.\n\nEx1 &lt;- c(\"tomate\",\"concombre\",\"mais\",\"courgette\",\"poivron\",\"carotte\",\"betterave\")\nEx1\n\n[1] \"tomate\"    \"concombre\" \"mais\"      \"courgette\" \"poivron\"   \"carotte\"  \n[7] \"betterave\"\n\n# Donne les indices des éléments contenant un \"o\" dans Ex\ngrep(pattern=\"o\",Ex1,value=FALSE) \n\n[1] 1 2 4 5 6\n\n# Donne les éléments de Ex1 qui contiennent la lettre \"o\"\ngrep(pattern=\"o\",Ex1, value = TRUE) \n\n[1] \"tomate\"    \"concombre\" \"courgette\" \"poivron\"   \"carotte\"  \n\n\n\n\nPour remplacer un pattern dans une chaine de caractère, on peut utiliser la fonction gsub().\n\nEx1\n\n[1] \"tomate\"    \"concombre\" \"mais\"      \"courgette\" \"poivron\"   \"carotte\"  \n[7] \"betterave\"\n\ngsub(pattern = \"o\" , replacement = \"@\" , Ex1, fixed = TRUE)\n\n[1] \"t@mate\"    \"c@nc@mbre\" \"mais\"      \"c@urgette\" \"p@ivr@n\"   \"car@tte\"  \n[7] \"betterave\""
  },
  {
    "objectID": "TP1-InitR.html#vecteurs-vector",
    "href": "TP1-InitR.html#vecteurs-vector",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.4 Vecteurs (vector)",
    "text": "2.4 Vecteurs (vector)\nUn vecteur est un ensemble ordonné d’éléments de même nature (numérique, logique ou alphanumérique). La création d’un vecteur peut se faire par la commande c(e1,e2,...). On peut également générer une séquence avec la commande seq(a,b,t) où \\(a\\) est le premier terme, le dernier terme est \\(\\leq b\\) et le pas est \\(t\\). Pour créer un vecteur constitué de l’élément \\(x\\) répété \\(n\\) fois, on utilise la commande rep(x,n).\n\n2.4.1 Exemples\nOn donne ici quelques exemples à tester sous R pour vous familiariser avec les vecteurs. En particulier, vous pouvez découvrir des fonctions utiles avec les vecteurs comme length(), sum(), sort(), … , les opérations usuelles, l’extraction d’éléments d’un vecteur, …\n\nCommande c(...)Commande seq(...)Commande rep(...)Extraire des élémentsOpérationsFonctions usuelles\n\n\n\nd &lt;- c(2,3,5,8,4,6)\nd\n\n[1] 2 3 5 8 4 6\n\nis.vector(d)\n\n[1] TRUE\n\nc(2,5,\"toto\")\n\n[1] \"2\"    \"5\"    \"toto\"\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\nseq(1,10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(from=1,to=20,by=2) \n\n [1]  1  3  5  7  9 11 13 15 17 19\n\nseq(1,20,by=5)\n\n[1]  1  6 11 16\n\nseq(1,20,length=5)\n\n[1]  1.00  5.75 10.50 15.25 20.00\n\n\n\n\n\nrep(5,times=10)\n\n [1] 5 5 5 5 5 5 5 5 5 5\n\nrep(c(1,2),3)\n\n[1] 1 2 1 2 1 2\n\nrep(c(1,2),each=3)\n\n[1] 1 1 1 2 2 2\n\n\n\n\n\nd\n\n[1] 2 3 5 8 4 6\n\nd[2]\n\n[1] 3\n\nd[2:3]\n\n[1] 3 5\n\nd[c(1,3,6)]\n\n[1] 2 5 6\n\nd[-3]\n\n[1] 2 3 8 4 6\n\nd[-(1:2)]\n\n[1] 5 8 4 6\n\n\n\n\nAdditionner ou soustraire un scalaire d’un vecteur\n\nd+4\n\n[1]  6  7  9 12  8 10\n\nd-4\n\n[1] -2 -1  1  4  0  2\n\n\nMultiplier ou diviser un vecteur par un scalaire\n\n2*d\n\n[1]  4  6 10 16  8 12\n\nd/3\n\n[1] 0.6666667 1.0000000 1.6666667 2.6666667 1.3333333 2.0000000\n\n\nMultiplier/ diviser deux vecteurs terme à terme\n\ne&lt;- rep(2,6)\nd*e\n\n[1]  4  6 10 16  8 12\n\nd/e\n\n[1] 1.0 1.5 2.5 4.0 2.0 3.0\n\n\n\n\n\nd &lt;- c(2,3,5,8,4,6)\nd\n\n[1] 2 3 5 8 4 6\n\n\nLongueur d’un vecteur\n\nlength(d)\n\n[1] 6\n\n\nSomme des termes d’un vecteur numérique\n\nsum(d)\n\n[1] 28\n\n\nSomme des termes cumulés d’un vecteur numérique\n\ncumsum(d)\n\n[1]  2  5 10 18 22 28\n\n\nDifférence des termes successifs d’un vecteur numérique\n\ndiff(d)\n\n[1]  1  2  3 -4  2\n\n\nVérifier si d est un vecteur\n\nis.vector(d)\n\n[1] TRUE\n\n\nTransposition d’un vecteur\n\nt(d)\n\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    2    3    5    8    4    6\n\n\nProduit scalaire\n\nt(d)%*%e\n\n     [,1]\n[1,]   56\n\n\nNA (Not Available) signale une donnée manquante\n\nd[3] &lt;- NA\nd\n\n[1]  2  3 NA  8  4  6\n\nis.na(d)\n\n[1] FALSE FALSE  TRUE FALSE FALSE FALSE\n\nany(is.na(d))\n\n[1] TRUE\n\nall(is.na(d))\n\n[1] FALSE\n\n\nAutres fonctions interrsantes avec les vecteurs : abs(), sort(), order(), which(), …\n\na&lt;-c(3,-1,5,2,-7,3,9)\nabs(a)\n\n[1] 3 1 5 2 7 3 9\n\nsort(a)\n\n[1] -7 -1  2  3  3  5  9\n\norder(a)\n\n[1] 5 2 4 1 6 3 7\n\n\n\nb = a==3\nb\n\n[1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n\nsort(b)\n\n[1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n\n\n\ntext&lt;-c(\"petit\",\"moyen\",\"grand\")\nis.vector(text)\n\n[1] TRUE\n\n\n\nf = c(a=12,b=26,c=32,d=41)\nf\n\n a  b  c  d \n12 26 32 41 \n\nnames(f)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\nf[\"a\"]\n\n a \n12 \n\nnames(f)&lt;-c(\"a1\",\"a2\",\"a3\",\"a4\")\nf\n\na1 a2 a3 a4 \n12 26 32 41 \n\n\nNotez la différence entre les commandes suivantes :\n\nf&gt;30\n\n   a1    a2    a3    a4 \nFALSE FALSE  TRUE  TRUE \n\nf[f&gt;30]\n\na3 a4 \n32 41 \n\nwhich(f&gt;30)\n\na3 a4 \n 3  4 \n\n\n\nf[2] &lt;- 22\nf+100\n\n a1  a2  a3  a4 \n112 122 132 141 \n\n\nEtonnant ces commandes suivantes, non ?\n\nf\n\na1 a2 a3 a4 \n12 22 32 41 \n\nd\n\n[1]  2  3 NA  8  4  6\n\nf+d\n\nWarning in f + d: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 14 25 NA 49 16 28\n\n\nOn peut appliquer une fonction à tous les éléments d’un vecteur facilement.\n\ncos(f)\n\n        a1         a2         a3         a4 \n 0.8438540 -0.9999608  0.8342234 -0.9873393 \n\n\n\n\n\n\n\n2.4.2 Exercice\n\nEnoncéVotre réponse\n\n\nQuestion 1 : Créer les vecteurs suivants :\n\nle vecteur \\(a\\) constitué des entiers pairs jusqu’à 30\nle vecteur \\(b\\) contenant \\(v=5\\), deux fois la valeur de \\(v\\), puis un tiers de la valeur de \\(v\\), puis trois fois \\(v^2\\), puis \\(\\sqrt{v}\\), puis le quatrième élément de \\(a\\).\nle vecteur \\(c\\) contenant 6 chiffres compris entre 4 et 30 avec un écart constant entre éléments successifs.\nle vecteur \\(d\\) contenant la somme des éléments de \\(c\\), puis la longueur de \\(b\\), puis 5 fois le chiffre 3.\n\nQuestion 2 : Extraire du vecteur \\(a\\) :\n\nle quatrième élément\ntous les éléments sauf le quatrième\ntous les éléments supérieurs à 10\n\nQuestion 3 : À quoi sert la fonction unique ? Illustrer son fonctionnement sur un exemple.\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n\n# AIDEZ-VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#matrices-matrix",
    "href": "TP1-InitR.html#matrices-matrix",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.5 Matrices (matrix)",
    "text": "2.5 Matrices (matrix)\nComme les vecteurs, les matrices sont de mode quelconque mais ne contiennent que des éléments de même nature. Pour créer une matrice, on utilise la commande matrix(vec,nrow=n,ncol=p) où vec est le vecteur contenant les éléments de la matrice de taille \\(n\\) par \\(p\\), qui seront rangés en colonne sauf si l’option byrow=T est utilisée.\n\n2.5.1 Exemples\nOn donne ici quelques exemples à tester sous R pour vous familiariser avec les matrices. En particulier, vous pouvez découvrir des fonctions utiles avec les matrices comme dim(), t(), cbind(), rbind()… , les opérations usuelles dont la différence entre A*B et A%*%B, l’extraction d’éléments d’une matrice, …\n\nmatrix()Extrairecbind() / rbind()Fonctions utilesOpérations\n\n\n\nA = matrix(1:15,ncol=5)\nA\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\nclass(A)\n\n[1] \"matrix\" \"array\" \n\nB = matrix(1:15,nc=5,byrow=T)\nB2 = B\nB2[1,1]=\"toto\"\nB2\n\n     [,1]   [,2] [,3] [,4] [,5]\n[1,] \"toto\" \"2\"  \"3\"  \"4\"  \"5\" \n[2,] \"6\"    \"7\"  \"8\"  \"9\"  \"10\"\n[3,] \"11\"   \"12\" \"13\" \"14\" \"15\"\n\n\n\nrownames(A)=c(paste(\"ligne\",1:3,sep=\"\"))\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n\n\n\n\n\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n\nA[1,3]\n\nligne1 \n     7 \n\nA[,2]\n\nligne1 ligne2 ligne3 \n     4      5      6 \n\nA[2,]\n\n[1]  2  5  8 11 14\n\nA[1:3,c(2,5)]\n\n       [,1] [,2]\nligne1    4   13\nligne2    5   14\nligne3    6   15\n\nA[1:3,-c(2,5)]\n\n       [,1] [,2] [,3]\nligne1    1    7   10\nligne2    2    8   11\nligne3    3    9   12\n\n\n\n\nPour concaténer deux matrices, on peut utiliser les fonctions rbind() ou cbind().\n\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n\nB\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n\ncbind(A,B)\n\n       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nligne1    1    4    7   10   13    1    2    3    4     5\nligne2    2    5    8   11   14    6    7    8    9    10\nligne3    3    6    9   12   15   11   12   13   14    15\n\nrbind(A,B)\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    4    7   10   13\nligne2    2    5    8   11   14\nligne3    3    6    9   12   15\n          1    2    3    4    5\n          6    7    8    9   10\n         11   12   13   14   15\n\n\n\n\nDimension d’une matrice\n\ndim(A)\n\n[1] 3 5\n\n\nNombre de lignes et de colonnes\n\nnrow(A)\n\n[1] 3\n\nncol(A)\n\n[1] 5\n\n\nTransposée et déterminant d’une matrice\n\nt(A)\n\n     ligne1 ligne2 ligne3\n[1,]      1      2      3\n[2,]      4      5      6\n[3,]      7      8      9\n[4,]     10     11     12\n[5,]     13     14     15\n\ndet(A[,3:5])\n\n[1] 0\n\n\nInversion d’une matrice\n\nsolve(A[1:2,2:3])\n\n        ligne1    ligne2\n[1,] -2.666667  2.333333\n[2,]  1.666667 -1.333333\n\n\nMatrice diagonale et diagonale d’une matrice\n\ndiag(A)\n\n[1] 1 5 9\n\ndiag(1:5)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    2    0    0    0\n[3,]    0    0    3    0    0\n[4,]    0    0    0    4    0\n[5,]    0    0    0    0    5\n\n\nMatrice de booléens\n\nA&gt;5\n\n        [,1]  [,2] [,3] [,4] [,5]\nligne1 FALSE FALSE TRUE TRUE TRUE\nligne2 FALSE FALSE TRUE TRUE TRUE\nligne3 FALSE  TRUE TRUE TRUE TRUE\n\nA[A&lt;5]&lt;-0\nA\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    0    0    7   10   13\nligne2    0    5    8   11   14\nligne3    0    6    9   12   15\n\n\nQuelques autres fonctions sur les matrices\n\ncolSums(A)\n\n[1]  0 11 24 33 42\n\napply(A,2,sum)\n\n[1]  0 11 24 33 42\n\nrowSums(A)\n\nligne1 ligne2 ligne3 \n    30     38     42 \n\napply(A,1,sum)\n\nligne1 ligne2 ligne3 \n    30     38     42 \n\nrowMeans(A)\n\nligne1 ligne2 ligne3 \n   6.0    7.6    8.4 \n\napply(A,1,mean)\n\nligne1 ligne2 ligne3 \n   6.0    7.6    8.4 \n\napply(A,1,max)\n\nligne1 ligne2 ligne3 \n    13     14     15 \n\n\nRemarque : on reverra dans la section Programmation la fonction apply() qui permet en particulier d’éviter les boucles for.\n\n\n\nAttention à la multiplication matricielle %*% et la multiplication terme à terme *!\nOpérations terme à terme de 2 matrices\n\nA+B\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    1    2   10   14   18\nligne2    6   12   16   20   24\nligne3   11   18   22   26   30\n\nA*B\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    0    0   21   40   65\nligne2    0   35   64   99  140\nligne3    0   72  117  168  225\n\n\nMultiplication de matrices\n\nt(B) %*%A\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0   96  154  208  262\n[2,]    0  107  178  241  304\n[3,]    0  118  202  274  346\n[4,]    0  129  226  307  388\n[5,]    0  140  250  340  430\n\n\nMultiplication par un scalaire\n\n5*A\n\n       [,1] [,2] [,3] [,4] [,5]\nligne1    0    0   35   50   65\nligne2    0   25   40   55   70\nligne3    0   30   45   60   75\n\n\n\n\n\n\n\n2.5.2 Exercice\n\nEnoncéVotre réponse\n\n\n\nCréer la matrice \\(A=\\left(\\begin{array}{c c c } 3 & 3 & 3\\\\ 4 & 4 & 4\\\\ 5 & 5 & 5\\end{array}\\right).\\)\nAjouter 2 à tous les éléments de \\(A\\).\nCréer la matrice \\(B\\) en ajoutant la ligne \\((1,2,3)\\) à \\(A\\), puis la colonne \\((1,1,1,1)'\\). Déterminer la dimension de \\(B\\).\nExtraire de \\(B\\) la sous-matrice \\(C\\) composée des deux premières colonnes et des deux dernières lignes. Calculer sa transposée et son déterminant. Inverser cette sous-matrice \\(C\\).\n\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#secList",
    "href": "TP1-InitR.html#secList",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.6 Listes (list)",
    "text": "2.6 Listes (list)\nUne liste est une collection ordonnée d’objets qui peuvent être de nature différente. Les listes sont en particulier utilisées par certaines fonctions (cf section Programmation) pour renvoyer des résultats complexes sous forme d’un seul objet. On utilise la fonction list(nom1=el1,nom2=el2,...) (l’utilisation des noms étant facultative) pour générer une liste. On peut accéder à chaque élément de la liste à l’aide de son index entre double crochets [[...]], ou par son nom précédé du signe $.\n\n2.6.1 Exemples\n\nlist(...)ExtractionFonctions utiles\n\n\n\nx = list(\"toto\",1:8)\nx\n\n[[1]]\n[1] \"toto\"\n\n[[2]]\n[1] 1 2 3 4 5 6 7 8\n\nclass(x)\n\n[1] \"list\"\n\n\nCréation d’une liste avec des noms aux éléments\n\ny = list(matrice=matrix(1:15,ncol=5),\n         vecteur=seq(1,20,by=5),\n         texte=\"toto\",scalaire=8)\ny\n\n$matrice\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\n$vecteur\n[1]  1  6 11 16\n\n$texte\n[1] \"toto\"\n\n$scalaire\n[1] 8\n\n\n\n\nExtraction d’un élément par son numéro\n\nx[[1]]\n\n[1] \"toto\"\n\n\nAttention, cette commande n’est pas possible:\n\nx[[1]]+1\n\npar contre celle-ci est possible\n\nx[[2]]+10\n\n[1] 11 12 13 14 15 16 17 18\n\n\n\ny[[1]]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\ny$matrice\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    7   10   13\n[2,]    2    5    8   11   14\n[3,]    3    6    9   12   15\n\ny$vec\n\n[1]  1  6 11 16\n\ny[c(\"texte\",\"scalaire\")]\n\n$texte\n[1] \"toto\"\n\n$scalaire\n[1] 8\n\n\n\n\n\nnames(y)\n\n[1] \"matrice\"  \"vecteur\"  \"texte\"    \"scalaire\"\n\nlength(y)\n\n[1] 4\n\nlength(y$vecteur)\n\n[1] 4\n\ncos(y$scal)+y[[2]][1]\n\n[1] 0.8545\n\nsummary(y)\n\n         Length Class  Mode     \nmatrice  15     -none- numeric  \nvecteur   4     -none- numeric  \ntexte     1     -none- character\nscalaire  1     -none- numeric  \n\n\n\n\n\n\n\n2.6.2 Exercice\n\nEnoncéVotre réponse\n\n\n\nCréer une liste contenant le nom de trois matières, les notes de 5 élèves pour chacune de ces matières, l’âge des 5 élèves et la filière (PO) d’appartenance de ces 5 élèves.\nRécupérer les notes du 4ème élève\nCréer une matrice contenant les notes et l’âge des 5 élèves.\n\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#data-frames",
    "href": "TP1-InitR.html#data-frames",
    "title": "TP 1 : Introduction au langage R",
    "section": "2.7 Data frames",
    "text": "2.7 Data frames\nSous R, un data.frame est analogue à une matrice mais le contenu des colonnes peut être ici hétérogène. Un tableau de données est un ensemble de vecteurs rangés colonne par colonne, chaque colonne correspondant à une variable, chaque ligne à un individu. En particulier, lors d’études statistiques, les données à étudier sont souvent représentées par un data.frame sous R. Pour créer un tableau de données, on peut regrouper des variables de même longueur à l’aide de la commande data.frame(nom1=var1,nom2=var2,...). On peut par exemple transformer une matrice en un tableau de données en utilisant la commande as.data.frame(mat).\n\n2.7.1 Exemple\nOn donne ici quelques exemples à tester sous R pour vous familiariser avec les data.frames. En particulier, vous pouvez découvrir des fonctions utiles dont summary(), attach(), …\n\ndata.frame()summary()/head()data.frame / list/matrixattach()/detach()\n\n\n\n# Création du data.frame H\ntaille = runif(12,150,180)\nmasse = runif(12,50,90)\nsexe = rep(c(\"M\",\"F\",\"F\",\"M\"),3)\nH = data.frame(taille,masse,sexe)\nH\n\n     taille    masse sexe\n1  151.7084 59.41214    M\n2  154.8058 74.65836    F\n3  160.0682 58.63527    F\n4  179.1806 77.68620    M\n5  164.1915 88.39817    M\n6  164.7805 54.12598    F\n7  178.2068 87.31862    F\n8  173.3186 68.14417    M\n9  163.5896 53.95541    M\n10 172.3228 54.64983    F\n11 171.8367 54.97216    F\n12 166.9675 59.86413    M\n\nclass(H)\n\n[1] \"data.frame\"\n\n\n\n\nLa fonction summary() permet de résumer le contenu des différentes colonnes d’un data.frame.\n\nsummary(H)\n\n     taille          masse           sexe          \n Min.   :151.7   Min.   :53.96   Length:12         \n 1st Qu.:162.7   1st Qu.:54.89   Class :character  \n Median :165.9   Median :59.64   Mode  :character  \n Mean   :166.7   Mean   :65.99                     \n 3rd Qu.:172.6   3rd Qu.:75.42                     \n Max.   :179.2   Max.   :88.40                     \n\n\nLa fonction head() permet de visualiser les premières lignes d’un data.frame\n\nhead(H)\n\n    taille    masse sexe\n1 151.7084 59.41214    M\n2 154.8058 74.65836    F\n3 160.0682 58.63527    F\n4 179.1806 77.68620    M\n5 164.1915 88.39817    M\n6 164.7805 54.12598    F\n\n\n\n\nAu travers de ces quelques commandes, vous pouvez voir les analogies entre data.frame, list et matrix mais restez prudent sur la nature de l’objet que vous manipulez!\n\nH[1,]\n\n    taille    masse sexe\n1 151.7084 59.41214    M\n\nH$taille\n\n [1] 151.7084 154.8058 160.0682 179.1806 164.1915 164.7805 178.2068 173.3186\n [9] 163.5896 172.3228 171.8367 166.9675\n\nH$sexe\n\n [1] \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\"\n\nis.data.frame(H)\n\n[1] TRUE\n\nis.matrix(H)\n\n[1] FALSE\n\nMH = as.matrix(H)\nMH\n\n      taille     masse      sexe\n [1,] \"151.7084\" \"59.41214\" \"M\" \n [2,] \"154.8058\" \"74.65836\" \"F\" \n [3,] \"160.0682\" \"58.63527\" \"F\" \n [4,] \"179.1806\" \"77.68620\" \"M\" \n [5,] \"164.1915\" \"88.39817\" \"M\" \n [6,] \"164.7805\" \"54.12598\" \"F\" \n [7,] \"178.2068\" \"87.31862\" \"F\" \n [8,] \"173.3186\" \"68.14417\" \"M\" \n [9,] \"163.5896\" \"53.95541\" \"M\" \n[10,] \"172.3228\" \"54.64983\" \"F\" \n[11,] \"171.8367\" \"54.97216\" \"F\" \n[12,] \"166.9675\" \"59.86413\" \"M\" \n\nsummary(MH)\n\n    taille             masse               sexe          \n Length:12          Length:12          Length:12         \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n\nas.list(H)\n\n$taille\n [1] 151.7084 154.8058 160.0682 179.1806 164.1915 164.7805 178.2068 173.3186\n [9] 163.5896 172.3228 171.8367 166.9675\n\n$masse\n [1] 59.41214 74.65836 58.63527 77.68620 88.39817 54.12598 87.31862 68.14417\n [9] 53.95541 54.64983 54.97216 59.86413\n\n$sexe\n [1] \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\"\n\n\n\n\nLa fonction attach() permet d’accéder aux variables d’un data.frame sans appeler le data.frame.\nLa fonction detach() peut être utilisée pour supprimer la variable d’un data.frame, qui était précédemment attachée avec attach().\n\nrm(taille)\nH$taille\n\n [1] 151.7084 154.8058 160.0682 179.1806 164.1915 164.7805 178.2068 173.3186\n [9] 163.5896 172.3228 171.8367 166.9675\n\nattach(H)\n\nThe following objects are masked _by_ .GlobalEnv:\n\n    masse, sexe\n\ntaille\n\n [1] 151.7084 154.8058 160.0682 179.1806 164.1915 164.7805 178.2068 173.3186\n [9] 163.5896 172.3228 171.8367 166.9675\n\ndetach(H) # taille est alors introuvable\n\n\n\n\n\n\n2.7.2 Exercice\n\nEnoncéVotre réponse\n\n\nOn reprend le data.frame \\(H\\) contruit dans la sous-section Exemple.\n\nExtraire la masse des individus dont la taille est supérieure à 160.\nExtraire la masse et le sexe de ces mêmes individus.\nExtraire la taille des individus de sexe masculin dont la masse est inférieure à 80 (c’est possible en une seule ligne avec &).\n\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#créer-une-fonction",
    "href": "TP1-InitR.html#créer-une-fonction",
    "title": "TP 1 : Introduction au langage R",
    "section": "3.1 Créer une fonction",
    "text": "3.1 Créer une fonction\nIl est possible sous R de construire ses propres fonctions. Il est conseillé d’écrire sa fonction dans un fichier nomfonction.R, puis dans la console, de charger la fonction grâce à la commande &gt;source(\"nomfonction.R\") et de l’utiliser. On peut également écrire directement la fonction dans la console. De manière générale, la définition d’une nouvelle fonction passe par l’expression suivante :\n\nnomfonction=function(arg1[=exp1],arg2[=exp2],...){\n    bloc d instructions\n    sortie = ...\n    return(sortie)\n}\n\nLes accolades signalent le début et la fin du code source de la fonction, les crochets indiquent le caractère facultatif des valeurs par défaut des arguments. L’objet sortie contient le ou les résultats retournés par la fonction, on peut en particulier utiliser une liste pour retourner plusieurs résultats.\n\n3.1.1 Exemples\n\nExemple 1Exemple 2\n\n\n\nMaFonction=function(x){x+2}\nMaFonction\n\nfunction (x) \n{\n    x + 2\n}\n\nMaFonction(3)\n\n[1] 5\n\nx = MaFonction(4)\nx\n\n[1] 6\n\n\n\nFonction2=function(a,b=7){a+b}\nFonction2(2,b=3)\n\n[1] 5\n\nFonction2(5)\n\n[1] 12\n\n\n\n\nFonction retournant le périmètre et la surface d’un cercle à partir de son rayon :\n\nCalculsCercle=function(r){\n    p=2*pi*r\n    s=pi*r*r\n    resultats = list(perimetre=p,surface=s)\n    return(resultats)\n}\nres=CalculsCercle(3)\nres\n\n$perimetre\n[1] 18.84956\n\n$surface\n[1] 28.27433\n\nres$surf\n\n[1] 28.27433\n\n\n\n\n\n\n\n3.1.2 Exercice\n\nEnoncéVotre réponse\n\n\n\nConstruire une fonction qui prend en argument deux réels x et y et qui retourne l’arrondi à 3 chiffres après la virgule de \\(x^2 + y\\). (Vous pouvez vous aider de la fonction round()).\nConstruire une fonction qui permet de calculer la densité de probabilité d’une loi normale de moyenne \\(m\\) et d’écart-type \\(s\\) au point \\(x\\).\n\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#structures-de-contrôle-et-itérations",
    "href": "TP1-InitR.html#structures-de-contrôle-et-itérations",
    "title": "TP 1 : Introduction au langage R",
    "section": "3.2 Structures de contrôle et itérations",
    "text": "3.2 Structures de contrôle et itérations\n\n3.2.1 Instructions conditionnelles\nLa syntaxe if(condition){instructions} permet de calculer les instructions uniquement si la condition est vraie. Le code if(condition){A}else{B} calcule les instructions A si la condition est vraie et les instructions B sinon. On peut également utiliser ifelse.\nDans l’exemple suivant, les deux commandes sont équivalentes :\n\nif(x&gt;0){y=x*log(x)}else{ y=0}\ny=ifelse(x&gt;0,x*log(x),0)\n\n\n3.2.1.1 Exercice\n\nEnoncéVotre réponse\n\n\nSoit \\(X\\) une variable aléatoire de loi de Poisson de paramètre 2. Écrire une fonction qui prend en argument un réel \\(x\\) et qui retourne la probabilité que \\(X\\) soit égal à \\(x\\).\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE\n\n\n\n\n\n\n\n3.2.2 Itérations\nOn utilise les boucles pour exécuter plusieurs fois une instruction ou un bloc d’instructions. Les trois types de boucle sont :\n\nla boucle for : for(var in seq){ commandes }\nla boucle while : while(cond){ commandes }\nla boucle repeat : repeat { commandes ; if (cond) break }\n\nDans une boucle for, le nombre d’itérations est fixe alors qu’il peut être infini pour les boucles while et repeat!\n\n3.2.2.1 Exemples\nPour illustrer les trois types de boucles, on a codé de trois façons différentes la somme des éléments d’un vecteur x ce qui correspond à la fonction sum() de R.\n\nExemple for()Exemple while()Exemple repeat()\n\n\n\nsomme1=function(x){\nt = 0\nfor (i in 1:length(x))\n  t = t+x[i]\nreturn(t)\n}\n\nx = seq(1:10)\nsomme1(x)\n\n[1] 55\n\nsum(x)\n\n[1] 55\n\n\n\n\n\nsomme2=function(x){\nt = 0\ni = 1\nwhile (i&lt;=length(x)){\nt = t+x[i]\ni = i+1\n}\nreturn(t)\n}\nx = seq(1:10)\nsomme2(x)\n\n[1] 55\n\nsum(x)\n\n[1] 55\n\n\n\n\n\nsomme3=function(x){\nt = 0\ni = 1\nrepeat{\nt = t+x[i]\ni = i+1\nif (i&gt; length(x)) break\n}\nreturn(t)\n}\n\nx = seq(1:10)\nsomme3(x)\n\n[1] 55\n\nsum(x)\n\n[1] 55\n\n\n\n\n\n\n\n3.2.2.2 Exercice\n\nEnoncéVotre réponse\n\n\n\nÉcrire une fonction ma.variance qui calcule la variance empirique corrigée pour un vecteur \\(x = (x_1, . . . , x_n)\\). Comparer avec la fonction prédéfinie var().\nÉcrire une fonction qui calcule les \\(n\\) premiers termes de la suite de Fibonacci (\\(u_1=0, u_2=1, \\forall n&gt;2, u_n=u_{n-1}+u_{n-2}\\))\nEcrire une fonction qui prend en entrée un entier \\(x\\) et retourne sa factorielle \\(x!\\) avec une boucle for() puis avec une boucle while().\n\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#apply-et-ses-variantes",
    "href": "TP1-InitR.html#apply-et-ses-variantes",
    "title": "TP 1 : Introduction au langage R",
    "section": "3.3 apply() et ses variantes",
    "text": "3.3 apply() et ses variantes\nIl est recommandé d’éviter les boucles très chronophages. On peut utiliser pour cela la fonction apply() et ses variantes sapply(), lapply(), tapply() sur des vecteurs ou matrices.\nLa fonction apply() permet d’appliquer la même fonction FUN sur toutes les lignes (MARGIN=1) ou les colonnes (MARGIN=2) d’une matrice MAT : apply(MAT , MARGIN, FUN).\nLes fonctions lapply() et sapply() calculent la même fonction sur tous les éléments d’un vecteur ou d’une liste. La commande lapply(X,FUN, ARG.COMMUN) permet d’appliquer la fonction FUN à tous les éléments du vecteur ou de la liste X. Les valeurs de X sont affectées au premier argument de la fonction FUN. Si la fonction FUN a plusieurs paramètres d’entrée, ils sont spécifiés dans ARG.COMMUN. Cette fonction retourne le résultat sous la forme de listes. sapply() est une fonction similaire à lapply() mais le résultat est retourné sous forme de vecteurs, si possible.\nLa fonction tapply() applique une fonction FUN sur les sous-groupes d’un vecteur X définis par une variable de type factor GRP : tapply(X,GRP,FUN,...).\n\n3.3.1 Exemples\n\ndata(iris)\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\napply(iris[,1:4],2,sum)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       876.5        458.6        563.7        179.9 \n\napply(iris[,1:4],1,sum)\n\n  [1] 10.2  9.5  9.4  9.4 10.2 11.4  9.7 10.1  8.9  9.6 10.8 10.0  9.3  8.5 11.2\n [16] 12.0 11.0 10.3 11.5 10.7 10.7 10.7  9.4 10.6 10.3  9.8 10.4 10.4 10.2  9.7\n [31]  9.7 10.7 10.9 11.3  9.7  9.6 10.5 10.0  8.9 10.2 10.1  8.4  9.1 10.7 11.2\n [46]  9.5 10.7  9.4 10.7  9.9 16.3 15.6 16.4 13.1 15.4 14.3 15.9 11.6 15.4 13.2\n [61] 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 15.7 14.2 15.2 14.8 14.9\n [76] 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 14.4 15.5 16.0 14.3 14.0 13.3\n [91] 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 11.7 13.9 18.1 15.5 18.1 16.6 17.5\n[106] 19.3 13.6 18.3 16.8 19.4 16.8 16.3 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7\n[121] 18.1 15.3 19.2 15.7 17.8 18.2 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7\n[136] 19.1 17.7 16.8 15.6 17.5 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8\n\nlapply(iris[,1:4],sum)\n\n$Sepal.Length\n[1] 876.5\n\n$Sepal.Width\n[1] 458.6\n\n$Petal.Length\n[1] 563.7\n\n$Petal.Width\n[1] 179.9\n\nsapply(iris[,1:4],sum)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       876.5        458.6        563.7        179.9 \n\ntapply(iris[,1],iris[,5],sum)\n\n    setosa versicolor  virginica \n     250.3      296.8      329.4 \n\n\n\n\n3.3.2 Exercices\n\nEnoncé 1Enoncé 2Votre réponse\n\n\nSoit la fonction suivante :\n\nExo1=function(M){\n  res=rep(0,5)\n  for (i in 1:5){\n    tmp=0\n    for (j in 1:4) {tmp = tmp + M[i,j]}\n    res[i]=tmp\n  }\nreturn(res)\n}\n\nM=matrix(1:20,nrow=5,ncol=4)\nExo1(M)\n\nProposer une fonction équivalente sans aucune boucle.\n\n\n\nRéaliser une liste de \\(100\\) réalisations d’une loi normale \\(\\mathcal{N}(m,1)\\) pour \\(m=-2\\), \\(0\\) et \\(2\\) respectivement en utilisant lapply() et rnorm().\nCréer un vecteur contenant la moyenne de chaque échantillon de la question 1.\n\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#importation-dun-jeu-de-données",
    "href": "TP1-InitR.html#importation-dun-jeu-de-données",
    "title": "TP 1 : Introduction au langage R",
    "section": "5.1 Importation d’un jeu de données",
    "text": "5.1 Importation d’un jeu de données\nLire les explications données dans le tutoriel.\n\n5.1.1 Exercice\n\nEnoncéVotre réponse\n\n\nExecutez les commandes suivantes pour préparer l’exercice.\n\ndata(iris)\ndir.create(\"DataAux\")\nwrite.table(iris,file=\"DataAux/iris1.txt\",sep=\";\",row.names=F,col.names=T)\nrownames(iris)=paste(\"indiv\",1:nrow(iris),sep=\"-\")\nwrite.table(iris,file=\"DataAux/iris2.csv\",row.names=T,col.names=F)\nwrite.table(iris,file=\"DataAux/iris3.txt\",quote=FALSE, dec=\",\",sep=\"*\")\n\nChargez à l’aide de la fonction read.table() les données iris1.txt, iris2.csv et iris3.txt disponibles dans le dossier DataAux.\n\n\n\n#  A COMPLETER POUR REPONDRE A L'EXERCICE\n# AIDEZ VOUS DE LA CORRECTION DISPO SUR LE TUTORIEL SI VOUS ETES BLOQUE"
  },
  {
    "objectID": "TP1-InitR.html#exportation",
    "href": "TP1-InitR.html#exportation",
    "title": "TP 1 : Introduction au langage R",
    "section": "5.2 Exportation",
    "text": "5.2 Exportation\nLire les explications données dans le tutoriel ici"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Prérequis 4modIA ",
    "section": "",
    "text": "Prérequis de proba/statistique de 4modIA\n\n\n\nTP1 : Initiation à R et à la rédaction avec Quarto\nTP2 :\n\n\nPartie 1 : elle est consacrée aux notions de statistiques descriptives uni- et bi-dimensionnelles.\nPartie 2 : elle est consacrée à l’illustration de notions de statistique inférentielle paramétrique revues dans les séances de remise à niveau. On n’abordera ici que le cas gaussien."
  },
  {
    "objectID": "TP2-Stat-Correction.html",
    "href": "TP2-Stat-Correction.html",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "",
    "text": "Ce TP se décompose en deux parties indépendantes :\nRemarque : pensez à enlever les “eval: false” au fur et à mesure de l’avancement dans le TP dans la partie 2 pour avoir les résultats dans votre compte-rendu final de TP."
  },
  {
    "objectID": "TP2-Stat-Correction.html#récupération-du-jeu-de-données",
    "href": "TP2-Stat-Correction.html#récupération-du-jeu-de-données",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "1.1 Récupération du jeu de données",
    "text": "1.1 Récupération du jeu de données\nOn va étudier le jeu de données wine disponible sur la page moodle du cours. Commencez par récupérer ce jeu de données et sauvegardez le fichier dans votre dossier de travail.\nLe jeu de données wine  comprend des mesures physico-chimiques réalisées sur un échantillon de \\(600\\) vins (rouges et blancs) du Portugal. Ces mesures sont complétées par une évaluation sensorielle de la qualité par un ensemble d’experts. Chaque vin est décrit par les variables suivantes :\n\nQualite : son évaluation sensorielle par les experts (“bad”,“medium”,“good”),\nType : son type (1 pour un vin rouge, 0 pour un vin blanc),\nAcidVol : la teneur en acide volatile (en g/dm3 d’acide acétique),\nAcidCitr : la teneur en acide citrique (en g/dm3),\nSO2lbr : le dosage du dioxyde de soufre libre (en mg/dm3),\nSO2tot : le dosage du dioxyde de soufre total (en mg/dm3),\nDensite : la densité (en g/cm3),\nAlcool : le degré d’alcool (en % Vol.).\n\nDans un premier temps, commencez par charger le jeu de données à l’aide de la fonction read.table().\n\nData = read.table(\"wine.txt\",header=TRUE)\n\nVous pouvez voir les premières lignes du jeu de données :\n\nhead(Data)\n\n     Qualite Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium    1    0.62     0.01      8     46 0.99332   11.8\n5493  medium    0    0.34     0.10     17     63 0.99370    9.2\n5153  medium    0    0.22     0.22     39    110 0.99855    9.0\n5308  medium    0    0.35     0.46     61    183 0.99786    9.0\n3866  medium    0    0.42     0.32     20    167 0.99479   10.6\n694   medium    1    0.48     0.32     21    122 0.99840    9.4\n\n\nLe jeu de données contient 600 individus (correspondant aux 600 lignes) décrits par 8 variables (correspondant aux 8 colonnes).\nRemarquons que l’on peut obtenir les noms des variables grâce à la commande names(Data). Plus largement, on peut utiliser la commande attributes() :\n\nattributes(Data)\n\n$names\n[1] \"Qualite\"  \"Type\"     \"AcidVol\"  \"AcidCitr\" \"SO2lbr\"   \"SO2tot\"   \"Densite\" \n[8] \"Alcool\"  \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1] \"1352\" \"5493\" \"5153\" \"5308\" \"3866\" \"694\"  \"5085\" \"2280\" \"5231\" \"4388\"\n [11] \"4172\" \"4763\" \"4001\" \"3244\" \"4663\" \"3256\" \"3444\" \"3867\" \"3161\" \"6420\"\n [21] \"1590\" \"2155\" \"2258\" \"209\"  \"4560\" \"1981\" \"2166\" \"5430\" \"6496\" \"346\" \n [31] \"1288\" \"3615\" \"1837\" \"5637\" \"2520\" \"3046\" \"2983\" \"840\"  \"3185\" \"4690\"\n [41] \"6347\" \"728\"  \"240\"  \"6318\" \"2501\" \"3003\" \"4537\" \"4799\" \"141\"  \"3664\"\n [51] \"5167\" \"5291\" \"3383\" \"2712\" \"449\"  \"214\"  \"3216\" \"4917\" \"5005\" \"3501\"\n [61] \"1291\" \"3137\" \"998\"  \"1350\" \"6336\" \"492\"  \"3901\" \"4878\" \"5343\" \"5096\"\n [71] \"4516\" \"1118\" \"2680\" \"452\"  \"3937\" \"776\"  \"528\"  \"3445\" \"203\"  \"1175\"\n [81] \"5796\" \"2334\" \"3564\" \"1921\" \"4995\" \"1070\" \"5286\" \"4421\" \"5630\" \"273\" \n [91] \"896\"  \"5267\" \"742\"  \"956\"  \"4435\" \"414\"  \"2737\" \"1496\" \"455\"  \"3970\"\n[101] \"286\"  \"1535\" \"3144\" \"5473\" \"6308\" \"5051\" \"3502\" \"4286\" \"1408\" \"2581\"\n[111] \"6225\" \"4614\" \"3065\" \"54\"   \"6300\" \"2050\" \"5574\" \"3368\" \"2332\" \"4225\"\n[121] \"5508\" \"2830\" \"5669\" \"6141\" \"6395\" \"5337\" \"878\"  \"4190\" \"5778\" \"3316\"\n[131] \"5832\" \"5672\" \"1786\" \"2654\" \"1199\" \"5997\" \"1347\" \"4785\" \"5400\" \"2157\"\n[141] \"3552\" \"788\"  \"2624\" \"1912\" \"499\"  \"2522\" \"6456\" \"4425\" \"618\"  \"1139\"\n[151] \"5815\" \"1191\" \"1348\" \"771\"  \"5530\" \"858\"  \"4070\" \"5460\" \"4236\" \"5919\"\n[161] \"6340\" \"5170\" \"3266\" \"3696\" \"6310\" \"6269\" \"3258\" \"6313\" \"362\"  \"2374\"\n[171] \"4507\" \"1575\" \"3468\" \"5729\" \"6469\" \"510\"  \"6107\" \"1178\" \"4973\" \"4120\"\n[181] \"5295\" \"2076\" \"3989\" \"4518\" \"3184\" \"1198\" \"1847\" \"2285\" \"6022\" \"6087\"\n[191] \"113\"  \"5667\" \"3317\" \"933\"  \"4658\" \"1923\" \"4026\" \"2244\" \"226\"  \"1254\"\n[201] \"747\"  \"2809\" \"1137\" \"2067\" \"2455\" \"6163\" \"3977\" \"50\"   \"3418\" \"5477\"\n[211] \"2389\" \"6243\" \"65\"   \"3678\" \"3117\" \"4327\" \"4206\" \"1169\" \"4188\" \"5392\"\n[221] \"1477\" \"3063\" \"6342\" \"4634\" \"3862\" \"1497\" \"193\"  \"2273\" \"3074\" \"583\" \n[231] \"6169\" \"3865\" \"5812\" \"2658\" \"4152\" \"753\"  \"4000\" \"5504\" \"1861\" \"6068\"\n[241] \"4950\" \"4654\" \"1511\" \"1001\" \"2386\" \"1242\" \"2045\" \"2743\" \"1413\" \"2060\"\n[251] \"5915\" \"469\"  \"5454\" \"4119\" \"397\"  \"1278\" \"2307\" \"1279\" \"4528\" \"761\" \n[261] \"3747\" \"199\"  \"802\"  \"4150\" \"271\"  \"5070\" \"6303\" \"146\"  \"3768\" \"4665\"\n[271] \"2703\" \"5349\" \"1693\" \"1640\" \"5547\" \"354\"  \"4161\" \"3230\" \"1319\" \"3832\"\n[281] \"2894\" \"3282\" \"5782\" \"570\"  \"5111\" \"6433\" \"229\"  \"5419\" \"2174\" \"1749\"\n[291] \"4782\" \"5163\" \"6059\" \"4836\" \"5635\" \"6054\" \"6437\" \"3347\" \"684\"  \"48\"  \n[301] \"2117\" \"1224\" \"96\"   \"4131\" \"2726\" \"2511\" \"6262\" \"3086\" \"1253\" \"4549\"\n[311] \"723\"  \"5287\" \"3739\" \"1658\" \"76\"   \"1604\" \"149\"  \"554\"  \"349\"  \"639\" \n[321] \"416\"  \"2966\" \"378\"  \"475\"  \"1212\" \"5670\" \"15\"   \"4986\" \"324\"  \"3657\"\n[331] \"5571\" \"881\"  \"322\"  \"1998\" \"3795\" \"5064\" \"232\"  \"5447\" \"2232\" \"5307\"\n[341] \"3578\" \"4645\" \"6277\" \"6483\" \"1028\" \"5649\" \"1493\" \"52\"   \"4329\" \"5765\"\n[351] \"4927\" \"4871\" \"5099\" \"419\"  \"2019\" \"3490\" \"5412\" \"4310\" \"2156\" \"4040\"\n[361] \"4791\" \"6205\" \"1295\" \"4177\" \"2216\" \"6355\" \"4493\" \"4428\" \"3089\" \"2142\"\n[371] \"4354\" \"5650\" \"2801\" \"2977\" \"919\"  \"1951\" \"3641\" \"5697\" \"6452\" \"3271\"\n[381] \"4515\" \"3665\" \"4167\" \"6008\" \"6094\" \"605\"  \"5608\" \"2942\" \"2360\" \"4579\"\n[391] \"4805\" \"239\"  \"612\"  \"4937\" \"3692\" \"4287\" \"2203\" \"1547\" \"5444\" \"872\" \n[401] \"4513\" \"6280\" \"5050\" \"2226\" \"5135\" \"5278\" \"2570\" \"4509\" \"2732\" \"1820\"\n[411] \"5495\" \"1882\" \"789\"  \"4290\" \"1249\" \"3306\" \"5468\" \"2342\" \"2217\" \"1252\"\n[421] \"1828\" \"832\"  \"4529\" \"2750\" \"5511\" \"4111\" \"2200\" \"695\"  \"611\"  \"1916\"\n[431] \"1646\" \"1774\" \"1977\" \"5298\" \"1007\" \"3956\" \"5659\" \"6\"    \"1365\" \"619\" \n[441] \"3131\" \"2941\" \"2027\" \"3838\" \"6039\" \"5624\" \"5323\" \"2730\" \"1783\" \"1579\"\n[451] \"3397\" \"3685\" \"5180\" \"1741\" \"5219\" \"5103\" \"997\"  \"1451\" \"2102\" \"309\" \n[461] \"3508\" \"4429\" \"2320\" \"4943\" \"1236\" \"5285\" \"1622\" \"2865\" \"254\"  \"581\" \n[471] \"4635\" \"198\"  \"5257\" \"5006\" \"2363\" \"922\"  \"399\"  \"3948\" \"2198\" \"5393\"\n[481] \"4609\" \"5299\" \"2598\" \"1214\" \"5875\" \"3626\" \"4087\" \"783\"  \"1482\" \"290\" \n[491] \"5956\" \"3011\" \"2293\" \"6176\" \"3871\" \"5478\" \"1123\" \"319\"  \"2469\" \"4151\"\n[501] \"2395\" \"4073\" \"2072\" \"1762\" \"1775\" \"3325\" \"1560\" \"3769\" \"5755\" \"4011\"\n[511] \"6389\" \"4958\" \"3523\" \"1452\" \"4576\" \"5182\" \"1179\" \"1059\" \"6467\" \"369\" \n[521] \"5795\" \"1836\" \"1684\" \"1737\" \"988\"  \"5853\" \"1201\" \"866\"  \"110\"  \"775\" \n[531] \"5303\" \"1938\" \"1283\" \"5636\" \"1474\" \"3236\" \"2262\" \"2881\" \"892\"  \"2032\"\n[541] \"129\"  \"6375\" \"1044\" \"540\"  \"3219\" \"3183\" \"1895\" \"2631\" \"1354\" \"655\" \n[551] \"4963\" \"3040\" \"4729\" \"6286\" \"5823\" \"4224\" \"729\"  \"719\"  \"5217\" \"3569\"\n[561] \"1447\" \"1394\" \"4794\" \"1664\" \"501\"  \"3668\" \"3098\" \"1080\" \"2266\" \"186\" \n[571] \"5841\" \"3375\" \"1111\" \"430\"  \"677\"  \"3973\" \"6471\" \"1021\" \"3674\" \"6203\"\n[581] \"2762\" \"572\"  \"5960\" \"970\"  \"460\"  \"4630\" \"5655\" \"5365\" \"2020\" \"3275\"\n[591] \"5150\" \"3265\" \"3328\" \"3925\" \"1265\" \"768\"  \"670\"  \"1156\" \"2275\" \"974\" \n\n\nLa commande str() affiche quand à elle d’autres informations concernant les données. En particulier, on retrouve le type (data.frame) et la dimension (nombres d’observations et de variables) des données. En outre, pour chaque variable, on peut lire son nom, son format (entier, numérique, caractère) ainsi que ses premières valeurs.\n\nstr(Data)\n\n'data.frame':   600 obs. of  8 variables:\n $ Qualite : chr  \"medium\" \"medium\" \"medium\" \"medium\" ...\n $ Type    : int  1 0 0 0 0 1 0 0 0 0 ...\n $ AcidVol : num  0.62 0.34 0.22 0.35 0.42 0.48 0.21 0.28 0.3 0.4 ...\n $ AcidCitr: num  0.01 0.1 0.22 0.46 0.32 0.32 0.32 0.14 0.25 0.42 ...\n $ SO2lbr  : num  8 17 39 61 20 21 39 64 21 41 ...\n $ SO2tot  : int  46 63 110 183 167 122 113 159 124 176 ...\n $ Densite : num  0.993 0.994 0.999 0.998 0.995 ...\n $ Alcool  : num  11.8 9.2 9 9 10.6 9.4 10.2 10 10.8 9.4 ...\n\n\nOn voit ici que les variables sont de différentes natures :\n\nLes variables Qualite et Type sont des variables qualitatives\nLes autres variables sont quantitatives\n\nAttention à bien préciser à R les variables qui doivent être considérées comme qualitatives. Ici, on change donc la nature des variables Qualite et Type:\n\nData$Qualite=as.factor(Data$Qualite)\nData$Type=factor(Data$Type,labels=c(\"blanc\",\"rouge\"))\nhead(Data)\n\n     Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium rouge    0.62     0.01      8     46 0.99332   11.8\n5493  medium blanc    0.34     0.10     17     63 0.99370    9.2\n5153  medium blanc    0.22     0.22     39    110 0.99855    9.0\n5308  medium blanc    0.35     0.46     61    183 0.99786    9.0\n3866  medium blanc    0.42     0.32     20    167 0.99479   10.6\n694   medium rouge    0.48     0.32     21    122 0.99840    9.4\n\n\nOn peut obtenir un résumé rapide du jeu de données à l’aide de la fonction summary()\n\nsummary(Data)\n\n   Qualite       Type        AcidVol          AcidCitr          SO2lbr      \n bad   : 19   blanc:425   Min.   :0.1000   Min.   :0.0000   Min.   :  2.00  \n good  :110   rouge:175   1st Qu.:0.2400   1st Qu.:0.2400   1st Qu.: 15.75  \n medium:471               Median :0.3000   Median :0.3000   Median : 27.00  \n                          Mean   :0.3512   Mean   :0.3141   Mean   : 29.41  \n                          3rd Qu.:0.4300   3rd Qu.:0.3900   3rd Qu.: 41.00  \n                          Max.   :1.0400   Max.   :1.0000   Max.   :112.00  \n     SO2tot         Densite           Alcool     \n Min.   :  7.0   Min.   :0.9875   Min.   : 8.00  \n 1st Qu.: 68.0   1st Qu.:0.9925   1st Qu.: 9.50  \n Median :114.5   Median :0.9949   Median :10.40  \n Mean   :111.2   Mean   :0.9947   Mean   :10.49  \n 3rd Qu.:154.0   3rd Qu.:0.9970   3rd Qu.:11.30  \n Max.   :278.0   Max.   :1.0030   Max.   :14.00"
  },
  {
    "objectID": "TP2-Stat-Correction.html#statistiques-descriptives-unidimensionnelles",
    "href": "TP2-Stat-Correction.html#statistiques-descriptives-unidimensionnelles",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "1.2 Statistiques descriptives unidimensionnelles",
    "text": "1.2 Statistiques descriptives unidimensionnelles\n\n1.2.1 Variable qualitative\nOn considère ici une variable qualitative \\(X\\) dont on observe \\(n\\) réalisations \\(\\underline{x}=(x_1,x_2,\\ldots,x_n)\\). Cette variable prend \\(K\\) modalités \\(m_1,\\ldots,m_K\\). Si les modalités n’ont pas d’ordre naturel, on parle de variable qualitative nominale (ex. Type), sinon c’est une variable qualitative ordinale (ex. Qualite).\nLa variable Type contient \\(K=\\) 2 modalités qui sont blanc, rouge.\n\nlevels(Data$Type)\n\n[1] \"blanc\" \"rouge\"\n\n\nOn récupère l’effectif \\(n_k=\\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i=m_k}\\) pour chaque modalité \\(m_k\\) avec summary() ou table().\n\nsummary(Data$Type)\n\nblanc rouge \n  425   175 \n\nEffType = as.vector(table(Data$Type))\nEffType\n\n[1] 425 175\n\n\nOn utilise aussi les fréquences \\(f_k=\\frac{n_k}{n}\\) donc \\(\\underset{k=1}{\\stackrel{K}{\\sum}} f_k=1\\).\n\nFreq = EffType/length(Data$Type)\nknitr::kable(data.frame(modalite=levels(Data$Type),Eff=EffType,Freq=Freq), caption = 'Description de la variable Type',booktabs = TRUE,digits=3)\n\n\nDescription de la variable Type\n\n\nmodalite\nEff\nFreq\n\n\n\n\nblanc\n425\n0.708\n\n\nrouge\n175\n0.292\n\n\n\n\n\nPour une variable qualitative ordinale, on utilise également les effectifs cumulés \\(N_k=\\underset{\\ell=1}{\\stackrel{k}{\\sum}} n_\\ell\\) et les fréquences cumulées \\(F_k=\\underset{\\ell=1}{\\stackrel{k}{\\sum}} f_\\ell\\).\nPour une variable qualitative, on utilise la représentation par camembert (pie) ou diagramme en bâton (barplot)\n\ng1&lt;-ggplot(Data, aes(x=Type))+ \n  geom_bar()+\n  ylab(\"\")+ggtitle(\"Effectifs\")\ng2&lt;-ggplot(Data, aes(x = Type)) +  \n  geom_bar(aes(y = (..count..)/sum(..count..)))+\n  ylab(\"\")+ggtitle(\"Frequences\")\nquan &lt;- as.vector(table(Data$Type))/nrow(Data)\ndf &lt;- data.frame(group = levels(Data$Type),value = quan)\ng3&lt;-ggplot(df, aes(x=\"\", y=value, fill=group))+\n  geom_bar(width = 1, stat = \"identity\")+ \n  coord_polar(\"y\", start=0)+ \n  theme(legend.position=\"bottom\")\ngrid.arrange(g3,g1,g2,ncol=3)\n\n\n\n\nPour une variable qualitative ordinale, on peut également tracer les fréquences cumulées :\n\n\n\n\n\n\n\n1.2.2 Variable quantitative\nNous allons ici nous intéresser à l’étude d’une variable quantitative \\(X\\) dont on a \\(n\\) observations \\(\\underline{x}=(x_1,\\ldots,x_n)\\). On va illustrer cette section avec la variable Alcool. Vous pouvez reprendre l’étude pour les autres variables quantitatives du jeu de données.\n\n1.2.2.1 Indices statistiques\nNous rappelons les principaux indicateurs statistiques que l’on peut évaluer pour une série de mesures \\(\\underline{x}\\) : la moyenne, la médiane, la variance, l’écart-type ….\n\nMean/var/sdmin/max/rangemédiane / quartiles / quantiles\n\n\nLa moyenne de \\(\\underline{x}\\) : \\(\\bar{x} = \\frac{1}{n} \\sum_{i=1}^n x_i\\)\n\nmean(Data$Alcool)\n\n[1] 10.48592\n\n\nLa variance \\(s_x^2 = \\frac{1}{n}\\sum_{i=1}^n (x_i - \\bar{x})^2\\), la variance corrigée \\(var(\\underline{x})=\\frac{1}{n-1}\\sum_{i=1}^n (x_i - \\bar{x})^2\\) et l’écart-type corrigé \\(\\sqrt{var(\\underline{x})}\\). Attention les fonctions var() et sd() renvoient les valeurs corrigées de la variance et de l’écart-type respectivement.\n\nvar(Data$Alcool)\n\n[1] 1.316059\n\nsd(Data$Alcool)\n\n[1] 1.147196\n\n\n\n\nLa commande range() renvoie respectivement le minimum et le maximum. On peut aussi utiliser min()et max()\n\nrange(Data$Alcool)\n\n[1]  8 14\n\nmin(Data$Alcool)\n\n[1] 8\n\nmax(Data$Alcool)\n\n[1] 14\n\n\nOn peut alors récupérer l’étendue (\\(max(\\underline{x}) - min(\\underline{x})\\) ) avec le code suivant :\n\ndiff(range(Data$Alcool))\n\n[1] 6\n\n\n\n\nLa médiane est une valeur qui divise l’échantillon en deux sous-échantillons de même cardinal : \\(\\sum_{i=1}^n \\mathbb{1}_{x_i\\geq m} \\geq \\frac{n}{2} \\textrm{ et } \\sum_{i=1}^n \\mathbb{1}_{x_i\\leq m} \\geq \\frac{n}{2}\\)\n\nmedian(Data$Alcool)\n\n[1] 10.4\n\nsort(Data$Alcool)[296:305]\n\n [1] 10.3 10.3 10.3 10.3 10.4 10.4 10.4 10.4 10.4 10.4\n\n\nLa médiane est le deuxième des trois quartiles :\n\nle premier quartile \\(q_{0.25}\\) est une valeur qui sépare les 25\\(\\%\\) des valeurs inférieures de l’échantillon du reste\nle deuxième quartile \\(q_{0.5}\\) est la médiane\nle troisième quartile \\(q_{O.75}\\) est une valeur qui sépare les 25% des valeurs supérieures de l’échantillon du reste. On retrouve ces valeurs dans la représentation par boxplot (voir plus bas).\n\nLes quartiles sont des cas particuliers de la notion de quantile. Le \\(\\alpha\\)-quantile empirique est défini par \\(q_{\\alpha} = x_{(i)}\\) avec \\(\\alpha\\in]\\frac{i-1}{n}, \\frac{i}{n}]\\) où \\(x_{(1)}\\leq x_{(2)}\\leq \\ldots \\leq x_{(n)}\\) sont les valeurs ordonnées de la série statistique.\n\nquantile(Data$Alcool)\n\n  0%  25%  50%  75% 100% \n 8.0  9.5 10.4 11.3 14.0 \n\nquantile(Data$Alcool,0.9)\n\n 90% \n12.1 \n\n\nPour calculer l’écart interquantile, il suffit de faire la différence entre les troisième et premier quantiles, à savoir\n\nq.Alc &lt;- quantile(x = Data$Alcool, probs=c(.25,.75), names=FALSE)\ndiff(q.Alc)\n\n[1] 1.8\n\n\net les valeurs d’adjacence sont obtenues de la manière suivante :\n\nL=q.Alc + diff(q.Alc) * c(-1.5,1.5) ; L\n\n[1]  6.8 14.0\n\n# valeur adjacente inférieure :\nmin(Data$Alcool[Data$Alcool&gt;=L[1]])\n\n[1] 8\n\n# valeur adjacente supérieure :\nmax(Data$Alcool[Data$Alcool&lt;=L[2]])\n\n[1] 14\n\n\nPar ailleurs, toutes ces informations sont stockées dans la commande summary() :\n\nsummary(Data$Alcool)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   8.00    9.50   10.40   10.49   11.30   14.00 \n\n\noù sont affichés respectivement le minimum, le premier quartile, la médiane, la moyenne, le troisième quartile et le maximum.\n\n\n\n\n\n1.2.2.2 Représentations graphiques\n\nHistogrammeFonction de répartition empiriqueBoîte à moustaches / boxplot\n\n\nL’histogramme est une représentation graphique qui permet de visualiser la répartition d’une variable quantitative. Les valeurs sont regroupées en intervalles \\(]a_k,a_{k+1}[\\) et la hauteur associée est \\(h_k=\\frac{f_k}{a_{k+1} - a_k}\\).\n\ng1&lt;-ggplot(Data,aes(x=Alcool))+\n  geom_histogram(bins=15,color=\"black\", fill=\"white\")+\n  ggtitle(\"Histo. des effectifs\")+\n  ylab(\"Frequency\")+xlab(\"Alcool\")\ng2&lt;-ggplot(Data,aes(x=Alcool))+\n  geom_histogram(aes(y=..density..),bins=15,color=\"black\", fill=\"white\")+ggtitle(\"Histo. des frequences\")+\n  ylab(\"Density\")+xlab(\"Alcool\")\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\nL’option breaks=\"Sturges\" donne le choix par défaut de R pour le nombre de classes. D’autres options sont possibles (soit on précise les classes elles mêmes dans un vecteur, soit on précise un nombre arbitraire de classes, soit on lui précise l’algorithme pour calculer le nombre de classes parmi \"Sturges\", \"Scott\" ou \"FD\" pour Freedman-Diaconis). On peut récupérer les informations de construction de l’histogramme en stockant le résultat de hist() dans une variable :\n\nH &lt;- hist(Data$Alcool,plot=FALSE)\nattributes(H)\n\n$names\n[1] \"breaks\"   \"counts\"   \"density\"  \"mids\"     \"xname\"    \"equidist\"\n\n$class\n[1] \"histogram\"\n\n\n\nH$breaks # les (K+1) bordures des classes [a_k,a_{k+1}]\nH$counts # le nombre de points dans chaque classe\nH$density # la hauteur des K classes\nH$mids # le milieu des K classes\nH$xname # le nom de la variable\nH$equidist # découpage régulier \n\n\n\nLa fonction de répartition empirique est la fonction en escalier définie par \\(t\\in\\mathbb{R}\\mapsto F_n(t) = \\frac{1}{n} \\sum_{i=1}^n \\mathbb{1}_{x_i\\leq t}\\)\n\nggplot(Data, aes(Alcool)) + \n  stat_ecdf(geom = \"step\")+\n  xlab(\"Variable Alcool\")+ylab(\"\")+\n  ggtitle(\"Fonction de répartition empirique\")+\n  geom_hline(yintercept=0, linetype=\"dashed\")+\n  geom_hline(yintercept=1, linetype=\"dashed\")\n\n\n\n\n\n\nLa boîte à moustaches est un graphique qui résume la série statistique à partir de ses valeurs extrêmes et ses quartiles. En effet, on retrouve sur cette représentation\n\nles quartiles\nla valeur adjacente supérieure \\(v+\\), qui est la plus grande valeur de l’échantillon inférieure ou égale à \\(L+ = q_{0.75} + 1.5 (q _{0.75} − q_{0.25})\\)\nla valeur adjacente inférieure \\(v−\\), qui est la plus petite valeur de l’échantillon supérieure ou égale à \\(L− = q_{0.25} − 1.5 (q_{0.75} − q_{0.25})\\)\nles valeurs extrêmes (outliers) qui sont les valeurs de l’échantillon n’appartenant pas à l’intervalle \\([v−, v+]\\).\n\nVoici les boxplots pour les variables quantitatives de notre exemple.\n\nlibrary(reshape2)\n\n\nAttaching package: 'reshape2'\n\n\nThe following object is masked from 'package:tidyr':\n\n    smiths\n\ng1&lt;-ggplot(melt(Data[,-c(1,2)]),aes(x=variable,y=value))+\n  geom_boxplot()\n\nNo id variables; using all as measure variables\n\ng1\n\n\n\n\nNous allons pour la suite nous concentrer sur la variable SO2lbr. En plus du graphique, on peut récupérer de la fonction boxplot() différentes informations :\n\nB &lt;- boxplot(Data$SO2lbr,horizontal=TRUE)\n\n\n\nattributes(B)\n\n$names\n[1] \"stats\" \"n\"     \"conf\"  \"out\"   \"group\" \"names\"\n\nggplot(Data,aes(y=SO2lbr))+\n  geom_boxplot()+\n  coord_flip()\n\n\n\n\nDans B$stats, on retrouve les quartiles, la médiane et les valeurs adjacentes :\n\nB$stats\n\n     [,1]\n[1,]  2.0\n[2,] 15.5\n[3,] 27.0\n[4,] 41.0\n[5,] 73.5\n\nmedian(Data$SO2lbr)\n\n[1] 27\n\nq &lt;- quantile(x = Data$SO2lbr, probs=c(.25,.75), names=FALSE)\nq\n\n[1] 15.75 41.00\n\nL=q + diff(q) * c(-1.5,1.5) \nmin(Data$SO2lbr[Data$SO2lbr&gt;=L[1]])\n\n[1] 2\n\nmax(Data$SO2lbr[Data$SO2lbr&lt;=L[2]])\n\n[1] 73.5\n\n\nDans B$out renvoie toutes les valeurs aberrantes (en dehors des barres inférieure et supérieure c’est à dire en dehors de l’intervalle \\([v-,v+]\\)):\n\nB$out\n\n[1]  89.0 105.0  85.0 112.0  79.5\n\nData$SO2lbr[which(Data$SO2lbr&lt;B$stats[1] | Data$SO2lbr&gt;B$stats[5])]\n\n[1]  89.0 105.0  85.0 112.0  79.5"
  },
  {
    "objectID": "TP2-Stat-Correction.html#statistiques-descriptives-bidimensionnelles",
    "href": "TP2-Stat-Correction.html#statistiques-descriptives-bidimensionnelles",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "1.3 Statistiques descriptives bidimensionnelles",
    "text": "1.3 Statistiques descriptives bidimensionnelles\n\n1.3.1 Entre 2 variables quantitatives\nSupposons dans cette partie que X et Y sont deux variables quantitatives et on observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\).\nOn peut tout d’abord représenter le nuage de points de coordonnées \\((x_i,y_i)\\) :\n\nggplot(Data,aes(x=Alcool,y=Densite))+\n  geom_point()\n\n\n\n\n\n1.3.1.1 Corrélation\nOn peut calculer la covariance (généralisaton bidimensionnelle de la variance) entre ces deux séries de mesure à l’aide de la commande cov(): \\[\nCov(\\underline{x},\\underline{y}) = \\frac{1}{n} \\sum_{i=1}^n (x_i-\\bar{x}) (y_i -\\bar{y}).\n\\] Mais la covariance dépendant des unités de mesure des deux variables considérées, on calcule plutôt la corrélation linéaire (renormalisation de la covariance par les écarts-type) qui appartient à l’intervalle \\([-1,1]\\) à l’aide de cor(): \\[\ncor(\\underline{x},\\underline{y}) = \\frac{Cov(\\underline{x},\\underline{y})}{\\sqrt{s_x^2\\ \\ s_y^2}}\n\\]\nA l’aide de la fonction corrplot() (issue du package du même nom) on représente ici la matrice des corrélations entre les variables quantitatives de notre jeu de données:\n\ncorrplot(cor(Data[,-c(1:2)]),method=\"ellipse\")\n\n\n\n\n\n\n1.3.1.2 Régression linéaire\nLe coefficient de corrélation linéaire entre les variables Densité et Alcool vaut -0.68. On peut vérifier que le nuage de points de ces deux variables s’aligner sur une droite de pente négative :\n\nggplot(Data,aes(x=Alcool,y=Densite))+\n  geom_point()+\n  geom_smooth(method=lm, se=FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n1.3.2 Entre une variable quantitative et une variable qualitative\nSupposons dans cette partie que \\(X\\) est une variable qualitative prenant \\(J\\) modalités \\(m_1, \\ldots, m_J\\) et \\(Y\\) une variable quantitative. On observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\).\nOn note \\(C_j=\\{i\\in\\{1,\\ldots,n\\}; x_i=m_j\\}\\) l’ensemble des individus prenant la modalité \\(m_j\\) et \\(n_j\\) son cardinal.\nLa moyenne de \\(\\underline{y}\\) peut alors se décomposer en une moyenne pondérée des moyennes de \\(y\\) conditionnellement aux modalités de \\(X\\) : \\[\n\\bar{y} = \\frac{1}{n} \\sum_{j=1}^J n_j\\ \\bar{y}_{[j]} \\textrm{   avec   } \\bar{y}_{[j]} = \\frac{1}{n_j} \\sum_{i\\in C_j} y_i\n\\] De même la variance se décompose en \\(s_y^2 = \\underbrace{s_{y,E}^2}_{\\textrm{variance inter-classe}} + \\underbrace{s_{y,R}^2}_{\\textrm{variance intra-classe}}\\) avec\n\\[\ns_{y,E}^2 = \\frac{1}{n} \\sum_{j=1}^J n_j\\ (\\bar{y}_{[j]} - \\bar{y})^2\n\\] et \\[\ns_{y,R}^2 = \\frac{1}{n} \\sum_{j=1}^J n_j\\ s_{y,[j]}^2 \\textrm{ avec } s^2_{y,[j]} = \\frac{1}{n_j}\\sum_{i\\in C_j} (y_i - \\bar{y}_{[j]})^2\n\\] On peut alors définir le rapport de corrélation \\[\n\\rho_{y|x} = \\sqrt{\\frac{s_{y,E}^2}{s_{y}^2}} = \\sqrt{1 - \\frac{s_{y,R}^2}{s_{y}^2}}\\in[0,1].\n\\] Plus \\(\\rho_{y|x}\\) est proche de \\(0\\), plus \\(s_{y,E}^2\\) est proche de 0 et donc moins la variable qualitative \\(X\\) a d’influence sur la variable quantitative \\(Y\\).\nGraphiquement, on peut représenter la distribution de la variable quantitative conditionnellement aux modalités de la variable qualitative pour visualiser la liaison potentielle entre les deux variables.\n\ng1&lt;-ggplot(Data,aes(x=Qualite,y=Alcool))+\n  geom_boxplot()\ng2&lt;-ggplot(Data,aes(x=Type,y=Alcool))+\n  geom_boxplot()\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\n\n\n1.3.3 Entre deux variables qualitatives\nSupposons dans cette partie que \\(X\\) est une variable qualitative prenant \\(J\\) modalités \\(m_1,\\ldots,m_J\\) et \\(Y\\) est une vraiable qualitative prenant \\(K\\) modalités \\(\\ell_1,\\ldots,\\ell_K\\). On observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\). Pour étudier l’influence de deux variables qualitatives entre elles, on se base sur la table de contingence qui est l’ensemble des effectifs conjoints \\[\nn_{j,k} = \\sum_{i=1}^n \\mathrm{1}_{x_i = m_j\\ \\cap\\ y_i=\\ell_k},\\ \\ \\forall j\\in\\{1,\\ldots,J\\},\\ \\forall k\\in\\{1,\\ldots,K\\}\n\\] On définit les effectifs marginaux par \\[\nn_{j,.}=\\sum_{k=1}^K n_{j,k}\\ \\ \\ \\textrm{   et   } \\ \\ \\ n_{.,k}=\\sum_{j=1}^J n_{j,k}\n\\]\n\ntable.cont = table(Data$Qualite,Data$Type)\ntable.cont\n\n        \n         blanc rouge\n  bad       17     2\n  good      89    21\n  medium   319   152\n\n\nGraphiquement, on peut représenter un mosaiplot qui correspond à la représentation des profils-lignes \\[\n\\left(\\frac{n_{j,1}}{n_{j,.}},\\ldots,\\frac{n_{j,K}}{n_{j,.}}\\right)\\in [0,1]^K\n\\] ou des profils-colonnes\n\\[\n\\left(\\frac{n_{1,k}}{n_{.,k}},\\ldots,\\frac{n_{J,k}}{n_{.,k}}\\right)\\in [0,1]^J\n\\]\n\nmosaicplot(table(Data$Qualite,Data$Type))\n\n\n\nmosaicplot(table(Data$Type,Data$Qualite))"
  },
  {
    "objectID": "TP2-Stat-Correction.html#estimateurs-pour-m-et-sigma2",
    "href": "TP2-Stat-Correction.html#estimateurs-pour-m-et-sigma2",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "2.1 Estimateurs pour \\(m\\) et \\(\\sigma^2\\)",
    "text": "2.1 Estimateurs pour \\(m\\) et \\(\\sigma^2\\)\nPour plusieurs valeurs de \\(n\\) :\n\nsimulez un \\(n\\)-échantillon observé \\(\\underline{x}\\) de \\(\\underline{X}\\) de loi \\(\\mathcal{N}(m,\\sigma^2)\\) avec \\(m=5\\) et \\(\\sigma^2=4\\) à l’aide de la fonction rnorm().\nA partir de \\(\\underline{x}\\), donnez une estimation pour le paramètre de moyenne \\(m\\) et pour le paramètre de variance \\(\\sigma^2\\).\nQue constatez-vous ?\n\n\nn=seq(100,10000,100)\nmest=NULL\nsigma2est=NULL\nfor (i in 1:length(n)){\n  x =  rnorm(n=n[i],mean=5,sd=2)               \n  mest = c(mest, mean(x))    \n  sigma2est=c(sigma2est, var(x))  \n}\n\nValeurs obtenues pour l’estimation de \\(m\\) :\n\ndf=data.frame(n=n,mest=mest,sigma2est=sigma2est)\nggplot(df,aes(x=n,y=mest))+\n  geom_point()+\n  geom_hline(yintercept=5, color=\"red\")\n\n\n\n\nValeurs obtenues pour l’estimation de \\(\\sigma^2\\) :\n\nggplot(df,aes(x=n,y=sigma2est))+\n  geom_point()+\n  geom_hline(yintercept=4, color=\"red\")"
  },
  {
    "objectID": "TP2-Stat-Correction.html#intervalle-de-confiance-pour-la-moyenne-m",
    "href": "TP2-Stat-Correction.html#intervalle-de-confiance-pour-la-moyenne-m",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "2.2 Intervalle de confiance pour la moyenne \\(m\\)",
    "text": "2.2 Intervalle de confiance pour la moyenne \\(m\\)\n\n2.2.1 Cas de la variance connue\nNous allons tout d’abord nous intéresser à la construction d’un intervalle de confiance pour \\(m\\) lorsque la variance \\(\\sigma^2\\) est connue, dont la formule est rappelée ici \\[\nIC_{1-\\alpha}(m) = \\left[\\bar X_n \\pm z_{1-\\frac{\\alpha}{2}} \\sqrt{\\frac{\\sigma^2}{n}}\\right]\n\\] où \\(z_{1-\\frac{\\alpha}{2}}\\) est le \\(1-\\frac{\\alpha}{2}\\)-quantile de la loi normale centrée réduite.\nReportez-vous aux slides de remise à niveau pour vous rappeler la construction.\n\nEcrivez une fonction int.conf.moy1 calculant \\(IC\\) au niveau de confiance niv.conf à partir d’un échantillon observé \\(\\underline{x}\\) et de la valeur de la variance sigma2\n\n\nint.conf.moy1 &lt;- function(x,niv.conf,sigma2){\n  alpha = 1-niv.conf\n  IC = mean(x) + c(-1,1) * qnorm(1-alpha/2) * sqrt(sigma2/length(x))\n  return(IC)\n}\n\n\nEtudiez le comportement de l’intervalle de confiance en fonction de \\(n\\) et du niveau de confiance sur données simulées. Pour cela, pour différentes valeurs de \\(n\\) et niv.conf,\n\n\nsimulez un échantillon \\(x\\) de taille \\(n\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ndéduisez-en un intervalle de confiance pour \\(m\\) au niveau de confiance niv.conf à l’aide de la fonction int.conf.moy1 programmée précédemment\n\n\nn= c(500,1000,5000,10000)\nniv.conf = c(0.9,0.95,0.99)\nfor (i in 1:length(n)){\n  for (j in 1:length(niv.conf)){\n    x= rnorm(n[i],mean=5,sd=2)\n    IC=int.conf.moy1(x,niv.conf[j],sigma2=4)\n    print(paste(\"n= \", n[i],\", niv.conf= \",niv.conf[j],\" : IC vaut [\", round(IC[1],3),\",\",round(IC[2],3),\"], il est de longueur\",round(IC[2]-IC[1],3), sep=\"\"))\n  }\n}\n\n[1] \"n= 500, niv.conf= 0.9 : IC vaut [4.985,5.279], il est de longueur0.294\"\n[1] \"n= 500, niv.conf= 0.95 : IC vaut [4.956,5.307], il est de longueur0.351\"\n[1] \"n= 500, niv.conf= 0.99 : IC vaut [4.82,5.281], il est de longueur0.461\"\n[1] \"n= 1000, niv.conf= 0.9 : IC vaut [4.923,5.131], il est de longueur0.208\"\n[1] \"n= 1000, niv.conf= 0.95 : IC vaut [4.88,5.128], il est de longueur0.248\"\n[1] \"n= 1000, niv.conf= 0.99 : IC vaut [4.882,5.208], il est de longueur0.326\"\n[1] \"n= 5000, niv.conf= 0.9 : IC vaut [4.952,5.045], il est de longueur0.093\"\n[1] \"n= 5000, niv.conf= 0.95 : IC vaut [4.901,5.012], il est de longueur0.111\"\n[1] \"n= 5000, niv.conf= 0.99 : IC vaut [4.964,5.11], il est de longueur0.146\"\n[1] \"n= 10000, niv.conf= 0.9 : IC vaut [4.971,5.036], il est de longueur0.066\"\n[1] \"n= 10000, niv.conf= 0.95 : IC vaut [4.924,5.002], il est de longueur0.078\"\n[1] \"n= 10000, niv.conf= 0.99 : IC vaut [4.954,5.057], il est de longueur0.103\"\n\n\n\nNous allons ici illustrer le fait que la proportion moyenne de fois où le paramètre \\(m\\) appartient à l’intervalle de confiance vaut niv.conf.\n\nPour cela, répétez \\(K\\) fois l’expérience suivante\n\nsimulez un échantillon \\(x\\) de taille \\(n=1000\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ndéduisez-en un intervalle de confiance pour \\(m\\) au niveau de confiance niv.conf=0.95 à l’aide de la fonction int.conf.moy1 programmée précédemment\ncomptabilisez si la vraie valeur de \\(m\\) appartient à l’intervalle de confiance ou pas\n\n\npropconf &lt;- function(K,m){\nnb.app=0\nfor (k in 1:K){\n  x= rnorm(n=1000,mean=m,sd=2)\n  IC=int.conf.moy1(x,niv.conf=0.95,sigma2=4)\n  nb.app = nb.app + (m&gt;=IC[1]) * (m&lt;=IC[2])\n}\nreturn(nb.app/K)\n}  \n\nEvaluez plusieurs fois pour \\(K\\) valant \\(100\\) et \\(1000\\). Qu’observez-vous ?\n\nnbrep=50\nval1=NULL\nfor (k in 1:nbrep)\n  val1=c(val1,propconf(K=100,m=5))\n\nval2=NULL\nfor (k in 1:nbrep)\n  val2=c(val2,propconf(K=1000,m=5))\n\ndf=data.frame(val=c(val1,val2),K=c(rep(\"K=100\",nbrep),rep(\"K=1000\",nbrep)))\nggplot(df,aes(x=K,y=val))+\n  geom_boxplot()+\n   geom_hline(yintercept=0.95, color=\"red\")\n\n\n\n\n\n\n2.2.2 Cas de la variance inconnue\nNous allons maintenant nous intéresser à la construction d’un intervalle de confiance pour \\(m\\) lorsque la variance \\(\\sigma^2\\) est inconnue, dont la formule est rappelée ici \\[\nIC_{1-\\alpha}(m) = \\left[\\bar X_n \\pm t_{1-\\frac{\\alpha}{2}} \\sqrt{\\frac{S^2}{n}}\\right]\n\\] où \\(t_{1-\\frac{\\alpha}{2}}\\) est le \\(1-\\frac{\\alpha}{2}\\)-quantile de la loi de Student à \\(n-1\\) degrés de liberté et \\(S^2\\) est l’estimateur de la variance.\nReportez-vous aux slides de remise à niveau pour vous rappeler la construction.\n\nEcrivez une fonction int.conf.moy2 calculant \\(IC\\) au niveau de confiance niv.conf à partir d’un échantillon observé \\(\\underline{x}\\).\n\n\nint.conf.moy2 &lt;- function(x,niv.conf){\n  alpha = 1-niv.conf\n  S2 =  var(x)\n  IC = mean(x) + c(-1,1) * qt(1-alpha/2,length(x)-1) * sqrt(S2/length(x))\n  return(IC)\n}\n\n\nEtudiez le comportement de l’intervalle de confiance en fonction de \\(n\\) et du niveau de confiance sur données simulées. Pour cela, pour différentes valeurs de \\(n\\) et niv.conf,\n\n\nsimulez un échantillon \\(x\\) de taille \\(n\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ndéduisez-en un intervalle de confiance pour \\(m\\) au niveau de confiance niv.conf à l’aide de la fonction int.conf.moy2 programmée précédemment\n\n\nn= c(500,1000,5000,10000)\nniv.conf = c(0.9,0.95,0.99)\nfor (i in 1:length(n)){\n  for (j in 1:length(niv.conf)){\n    x= rnorm(n[i],mean=5,sd=2)\n    IC=int.conf.moy2(x,niv.conf[j])\n    print(paste(\"n= \", n[i],\", niv.conf= \",niv.conf[j],\" : IC vaut [\", round(IC[1],3),\",\",round(IC[2],3),\"], il est de longueur\",round(IC[2]-IC[1],3), sep=\"\"))\n  }\n}\n\n[1] \"n= 500, niv.conf= 0.9 : IC vaut [4.989,5.277], il est de longueur0.287\"\n[1] \"n= 500, niv.conf= 0.95 : IC vaut [4.891,5.25], il est de longueur0.359\"\n[1] \"n= 500, niv.conf= 0.99 : IC vaut [4.738,5.188], il est de longueur0.45\"\n[1] \"n= 1000, niv.conf= 0.9 : IC vaut [4.819,5.029], il est de longueur0.21\"\n[1] \"n= 1000, niv.conf= 0.95 : IC vaut [4.83,5.07], il est de longueur0.24\"\n[1] \"n= 1000, niv.conf= 0.99 : IC vaut [4.891,5.213], il est de longueur0.322\"\n[1] \"n= 5000, niv.conf= 0.9 : IC vaut [4.956,5.049], il est de longueur0.093\"\n[1] \"n= 5000, niv.conf= 0.95 : IC vaut [4.905,5.016], il est de longueur0.112\"\n[1] \"n= 5000, niv.conf= 0.99 : IC vaut [4.942,5.087], il est de longueur0.146\"\n[1] \"n= 10000, niv.conf= 0.9 : IC vaut [4.996,5.063], il est de longueur0.067\"\n[1] \"n= 10000, niv.conf= 0.95 : IC vaut [4.972,5.05], il est de longueur0.078\"\n[1] \"n= 10000, niv.conf= 0.99 : IC vaut [4.929,5.033], il est de longueur0.103\"\n\n\n\nComparez sur données simulées les intervalles de confiance obtenus dans le cas de la variance connue (int.conf.moy1), le cas de la variance inconnue (int.conf.moy2) et avec la fonction t.test()de R.\n\n\nx = rnorm(n=1000,mean=5,sd=2)\nint.conf.moy1(x,niv.conf=0.95,sigma2=4)\n\n[1] 4.926437 5.174355\n\nint.conf.moy2(x,niv.conf=0.95)\n\n[1] 4.927728 5.173063\n\nt.test(x,conf.level=0.95)\n\n\n    One Sample t-test\n\ndata:  x\nt = 80.792, df = 999, p-value &lt; 2.2e-16\nalternative hypothesis: true mean is not equal to 0\n95 percent confidence interval:\n 4.927728 5.173063\nsample estimates:\nmean of x \n 5.050396"
  },
  {
    "objectID": "TP2-Stat-Correction.html#test-sur-la-moyenne",
    "href": "TP2-Stat-Correction.html#test-sur-la-moyenne",
    "title": "Correction du TP2 - Statistique avec R",
    "section": "2.3 Test sur la moyenne",
    "text": "2.3 Test sur la moyenne\nConsidérons \\(X_1,\\ldots,X_n\\) des variables aléatoires i.i.d. de loi \\(\\mathcal{N}(m,\\sigma^2)\\) (où \\(m\\) est inconnue) et soit \\(m_0 \\in \\mathbb{R}\\) donnée.\n\n2.3.1 Cas de la variance connue\n\nDans les trois tests suivants au niveau \\(\\alpha\\),\n\n\nTest 1 : \\(\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1^+ : m&gt; m_0\\)\nTest 2 : \\(\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1^{-} : m&lt; m_0\\)\nTest 3 : \\(\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1 : m\\neq m_0\\)\n\nprécisez\n\nla statistique de test et sa loi sous \\(\\mathcal{H}_0\\)\nla forme de la zone de rejet\nl’expression de la pvaleur en fonction de \\(\\phi\\) qui désigne la fonction de répartition d’une \\(\\mathcal{N}(0,1)\\)\n\n\nComplétez la fonction suivante test.moy1() qui évalue la p-valeur du test \\(\\mathcal{H}_0 : m=m_0\\) contre l’alternative\n\n\ntwo.sided pour le test bilatéral avec \\(\\mathcal{H}_1 : m\\neq m_0\\)\ngreaterpour le test unilatéral avec \\(\\mathcal{H}_1 : m&gt; m_0\\)\nlesspour le test unilatéral avec \\(\\mathcal{H}_1 : m &lt; m_0\\)\n\nà partir d’un échantillon observé \\(\\underline{x}\\) (supposé gaussien) et la valeur de la variance \\(\\sigma^2\\). Vous pourrez vous aider de la fonction pnorm().\n\ntest.moy1 &lt;- function(x,sigma2,m0,alternative=\"greater\"){\n  Zn.obs = sqrt(length(x))*(mean(x)-m0)/sqrt(sigma2)\n  if(alternative==\"two.sided\"){      \n      pval =  2*(1-pnorm(abs(Zn.obs))) \n  }else{\n      if(alternative==\"greater\"){      \n        pval = 1-pnorm(Zn.obs)\n      }else{\n        if(alternative==\"less\"){       \n          pval = pnorm(Zn.obs)\n        }\n      }\n    }\nreturn(pval)\n}\n\n\nAfin d’estimer la taille du test, complétez la fonction estim.prop.test.moy1() qui estime la proportion moyenne de fois où le test rejette l’hypothèse nulle \\(\\mathcal{H_0}\\). Pour cela, répétez \\(K\\) fois l’expérience suivante\n\n\nsimulez un échantillon \\(x\\) de taille \\(n=1000\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ncalculez la p-valeur obtenue avec la fonction test.moy1 programmée précédemment pour le test \\(\\mathcal{H}_0: m=5\\) contre \\(\\mathcal{H}_1^+: m&gt;5\\).\n\ncomptabilisez si l’hypothèse nulle est rejetée au niveau \\(\\alpha = 5\\%\\).\n\n\nestim.prop.test.moy1 &lt;-function(n=1000,m=5,sigma2=4,m0=5,alpha=0.05,K=100,alternative=\"greater\"){\n  nb.rejets=0\n  for(k in 1:K){\n      x=rnorm(n,m,sqrt(sigma2))\n      pval=test.moy1(x,sigma2,m0,alternative)\n      nb.rejets = nb.rejets + (pval&lt;=alpha)\n  }\nreturn(nb.rejets/K)\n}\n\nQu’observez-vous ? Répétez cette étape plusieurs fois pour \\(K=100\\) et \\(K=1000\\), que remarquez-vous ?\n\nnbrep=50\nval1=NULL\nfor (k in 1:nbrep)\n  val1=c(val1,estim.prop.test.moy1(n=1000,m=5,sigma2=4,m0=5,alpha=0.05,K=100,alternative=\"greater\"))\n\nval2=NULL\nfor (k in 1:nbrep)\n  val2=c(val2,estim.prop.test.moy1(n=1000,m=5,sigma2=4,m0=5,alpha=0.05,K=1000,alternative=\"greater\"))\n\ndf=data.frame(val=c(val1,val2),K=c(rep(\"K=100\",nbrep),rep(\"K=1000\",nbrep)))\nggplot(df,aes(x=K,y=val))+\n  geom_boxplot()+\n   geom_hline(yintercept=0.05, color=\"red\")\n\n\n\n\n\nEtude de la puissance du test \\(\\mathcal{H}_0: m=m_0\\) contre \\(\\mathcal{H}_1^+: m&gt;m_0\\)\n\n\nMontrez que la puissance théorique du test est donnée par l’expression suivante \\[\n\\Pi: \\theta\\in ]m_0,+\\infty[ \\mapsto 1 - \\Phi\\left(z_{1-\\alpha} - \\sqrt{n}\\ \\frac{\\theta - m_0}{\\sigma}\\right)\n\\] où \\(z_{1-\\alpha}\\) est le (1-)-quantile de la loi normale \\(\\mathcal{N}(0,1)\\) et \\(\\Phi\\) est la fonction de répartition de la loi normale \\(\\mathcal{N}(0,1)\\).\n\nCréez une fonction puiss.test.moy.1() pour calculer cette fonction puissance.\n\npuiss.test.moy.1 &lt;- function(n=1000,sigma2=4,m0=5,alpha=0.05,mmax){\n  theta = seq(m0,mmax,0.01)\n  puiss = 1 - pnorm(qnorm(1-alpha) - (sqrt(n/sigma2)*(theta-m0)))\n  return(puiss)\n}\n\nA l’aide de la fonction puiss.test.moy.1(), tracez sur un même graphique la fonction puissance en faisant varier le niveau \\(\\alpha\\) du test (\\(1\\%\\), \\(5\\%\\), \\(10\\%\\)) et commentez.\n\nmmax=6\ntheta=seq(5,mmax,0.01)\ndf = data.frame(puiss = c(puiss.test.moy.1(n=1000,sigma2=4,m0=5,alpha=0.01,mmax),puiss.test.moy.1(n=1000,sigma2=4,m0=5,alpha=0.05,mmax),puiss.test.moy.1(n=1000,sigma2=4,m0=5,alpha=0.1,mmax)),\n                alpha=c(rep(\"0.01\",length(theta)),rep(\"0.05\",length(theta)),rep(\"0.1\",length(theta))),\n                theta=rep(theta,3))\n\nggplot(df,aes(x=theta,y=puiss,colour=alpha))+\n  geom_line()\n\n\n\n\nA l’aide de la fonction puiss.test.moy.1(), tracez sur un même graphique la fonction puissance en faisant varier la taille de l’échantillon \\(n\\) et commentez.\n\nmmax=6.5\ntheta=seq(5,mmax,0.01)\n\ndf = data.frame(puiss = c(puiss.test.moy.1(n=100,sigma2=4,m0=5,alpha=0.05,mmax),puiss.test.moy.1(n=500,sigma2=4,m0=5,alpha=0.05,mmax),puiss.test.moy.1(n=1000,sigma2=4,m0=5,alpha=0.05,mmax)),\n                n=c(rep(\"100\",length(theta)),rep(\"500\",length(theta)),rep(\"1000\",length(theta))),\n                theta=rep(theta,3))\n\nggplot(df,aes(x=theta,y=puiss,colour=n))+\n  geom_line()\n\n\n\n\n\n\n2.3.2 Cas de la variance inconnue\nOn suppose maintenant que la variance \\(\\sigma^2\\) est inconnue et on s’intéresse uniquement au Test 1 \\[\n\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1^+ : m&gt; m_0\n\\] 1. Rappelez la statistique de test, la loi sous \\(\\mathcal{H}_0\\) et la forme de la zone de rejet pour le test 1 quand la variance est inconnue\n\nConstruisez une fonction test.moy2() pour évaluer la pvaleur du test à partir d’un échantillon observé \\(\\underline{x}\\). Vous pourrez vous aider de la fonction pt() pour la fonction de répartiion d’une loi de Student.\n\n\ntest.moy2 &lt;- function(x,m0){\n  Tn_obs = sqrt(length(x))*(mean(x)-m0)/sqrt(var(x))\n  pval = 1-pt(Tn_obs,df=length(x)-1)\n  return(pval)\n}\n\n\nComparez la pvaleur obtenue avec test.moy2() et la sortie de t.test() de R sur des données simulées.\n\n\nx = rnorm(n=1000,mean =5,sd=2)\ntest.moy2(x,m0=5)\n\n[1] 0.7123989\n\nt.test (x,mu=5,alternative=\"greater\") \n\n\n    One Sample t-test\n\ndata:  x\nt = -0.56059, df = 999, p-value = 0.7124\nalternative hypothesis: true mean is greater than 5\n95 percent confidence interval:\n 4.858467      Inf\nsample estimates:\nmean of x \n 4.964049"
  },
  {
    "objectID": "TP2-Stat.html",
    "href": "TP2-Stat.html",
    "title": "TP2 - Statistique avec R",
    "section": "",
    "text": "Ce TP se décompose en deux parties indépendantes :\nRemarque : pensez à enlever les “eval: false” au fur et à mesure de l’avancement dans le TP dans la partie 2 pour avoir les résultats dans votre compte-rendu final de TP."
  },
  {
    "objectID": "TP2-Stat.html#récupération-du-jeu-de-données",
    "href": "TP2-Stat.html#récupération-du-jeu-de-données",
    "title": "TP2 - Statistique avec R",
    "section": "1.1 Récupération du jeu de données",
    "text": "1.1 Récupération du jeu de données\nOn va étudier le jeu de données wine disponible sur la page moodle du cours. Commencez par récupérer ce jeu de données et sauvegardez le fichier dans votre dossier de travail.\nLe jeu de données wine  comprend des mesures physico-chimiques réalisées sur un échantillon de \\(600\\) vins (rouges et blancs) du Portugal. Ces mesures sont complétées par une évaluation sensorielle de la qualité par un ensemble d’experts. Chaque vin est décrit par les variables suivantes :\n\nQualite : son évaluation sensorielle par les experts (“bad”,“medium”,“good”),\nType : son type (1 pour un vin rouge, 0 pour un vin blanc),\nAcidVol : la teneur en acide volatile (en g/dm3 d’acide acétique),\nAcidCitr : la teneur en acide citrique (en g/dm3),\nSO2lbr : le dosage du dioxyde de soufre libre (en mg/dm3),\nSO2tot : le dosage du dioxyde de soufre total (en mg/dm3),\nDensite : la densité (en g/cm3),\nAlcool : le degré d’alcool (en % Vol.).\n\nDans un premier temps, commencez par charger le jeu de données à l’aide de la fonction read.table().\n\nData = read.table(\"wine.txt\",header=TRUE)\n\nVous pouvez voir les premières lignes du jeu de données :\n\nhead(Data)\n\n     Qualite Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium    1    0.62     0.01      8     46 0.99332   11.8\n5493  medium    0    0.34     0.10     17     63 0.99370    9.2\n5153  medium    0    0.22     0.22     39    110 0.99855    9.0\n5308  medium    0    0.35     0.46     61    183 0.99786    9.0\n3866  medium    0    0.42     0.32     20    167 0.99479   10.6\n694   medium    1    0.48     0.32     21    122 0.99840    9.4\n\n\nLe jeu de données contient 600 individus (correspondant aux 600 lignes) décrits par 8 variables (correspondant aux 8 colonnes).\nRemarquons que l’on peut obtenir les noms des variables grâce à la commande names(Data). Plus largement, on peut utiliser la commande attributes() :\n\nattributes(Data)\n\n$names\n[1] \"Qualite\"  \"Type\"     \"AcidVol\"  \"AcidCitr\" \"SO2lbr\"   \"SO2tot\"   \"Densite\" \n[8] \"Alcool\"  \n\n$class\n[1] \"data.frame\"\n\n$row.names\n  [1] \"1352\" \"5493\" \"5153\" \"5308\" \"3866\" \"694\"  \"5085\" \"2280\" \"5231\" \"4388\"\n [11] \"4172\" \"4763\" \"4001\" \"3244\" \"4663\" \"3256\" \"3444\" \"3867\" \"3161\" \"6420\"\n [21] \"1590\" \"2155\" \"2258\" \"209\"  \"4560\" \"1981\" \"2166\" \"5430\" \"6496\" \"346\" \n [31] \"1288\" \"3615\" \"1837\" \"5637\" \"2520\" \"3046\" \"2983\" \"840\"  \"3185\" \"4690\"\n [41] \"6347\" \"728\"  \"240\"  \"6318\" \"2501\" \"3003\" \"4537\" \"4799\" \"141\"  \"3664\"\n [51] \"5167\" \"5291\" \"3383\" \"2712\" \"449\"  \"214\"  \"3216\" \"4917\" \"5005\" \"3501\"\n [61] \"1291\" \"3137\" \"998\"  \"1350\" \"6336\" \"492\"  \"3901\" \"4878\" \"5343\" \"5096\"\n [71] \"4516\" \"1118\" \"2680\" \"452\"  \"3937\" \"776\"  \"528\"  \"3445\" \"203\"  \"1175\"\n [81] \"5796\" \"2334\" \"3564\" \"1921\" \"4995\" \"1070\" \"5286\" \"4421\" \"5630\" \"273\" \n [91] \"896\"  \"5267\" \"742\"  \"956\"  \"4435\" \"414\"  \"2737\" \"1496\" \"455\"  \"3970\"\n[101] \"286\"  \"1535\" \"3144\" \"5473\" \"6308\" \"5051\" \"3502\" \"4286\" \"1408\" \"2581\"\n[111] \"6225\" \"4614\" \"3065\" \"54\"   \"6300\" \"2050\" \"5574\" \"3368\" \"2332\" \"4225\"\n[121] \"5508\" \"2830\" \"5669\" \"6141\" \"6395\" \"5337\" \"878\"  \"4190\" \"5778\" \"3316\"\n[131] \"5832\" \"5672\" \"1786\" \"2654\" \"1199\" \"5997\" \"1347\" \"4785\" \"5400\" \"2157\"\n[141] \"3552\" \"788\"  \"2624\" \"1912\" \"499\"  \"2522\" \"6456\" \"4425\" \"618\"  \"1139\"\n[151] \"5815\" \"1191\" \"1348\" \"771\"  \"5530\" \"858\"  \"4070\" \"5460\" \"4236\" \"5919\"\n[161] \"6340\" \"5170\" \"3266\" \"3696\" \"6310\" \"6269\" \"3258\" \"6313\" \"362\"  \"2374\"\n[171] \"4507\" \"1575\" \"3468\" \"5729\" \"6469\" \"510\"  \"6107\" \"1178\" \"4973\" \"4120\"\n[181] \"5295\" \"2076\" \"3989\" \"4518\" \"3184\" \"1198\" \"1847\" \"2285\" \"6022\" \"6087\"\n[191] \"113\"  \"5667\" \"3317\" \"933\"  \"4658\" \"1923\" \"4026\" \"2244\" \"226\"  \"1254\"\n[201] \"747\"  \"2809\" \"1137\" \"2067\" \"2455\" \"6163\" \"3977\" \"50\"   \"3418\" \"5477\"\n[211] \"2389\" \"6243\" \"65\"   \"3678\" \"3117\" \"4327\" \"4206\" \"1169\" \"4188\" \"5392\"\n[221] \"1477\" \"3063\" \"6342\" \"4634\" \"3862\" \"1497\" \"193\"  \"2273\" \"3074\" \"583\" \n[231] \"6169\" \"3865\" \"5812\" \"2658\" \"4152\" \"753\"  \"4000\" \"5504\" \"1861\" \"6068\"\n[241] \"4950\" \"4654\" \"1511\" \"1001\" \"2386\" \"1242\" \"2045\" \"2743\" \"1413\" \"2060\"\n[251] \"5915\" \"469\"  \"5454\" \"4119\" \"397\"  \"1278\" \"2307\" \"1279\" \"4528\" \"761\" \n[261] \"3747\" \"199\"  \"802\"  \"4150\" \"271\"  \"5070\" \"6303\" \"146\"  \"3768\" \"4665\"\n[271] \"2703\" \"5349\" \"1693\" \"1640\" \"5547\" \"354\"  \"4161\" \"3230\" \"1319\" \"3832\"\n[281] \"2894\" \"3282\" \"5782\" \"570\"  \"5111\" \"6433\" \"229\"  \"5419\" \"2174\" \"1749\"\n[291] \"4782\" \"5163\" \"6059\" \"4836\" \"5635\" \"6054\" \"6437\" \"3347\" \"684\"  \"48\"  \n[301] \"2117\" \"1224\" \"96\"   \"4131\" \"2726\" \"2511\" \"6262\" \"3086\" \"1253\" \"4549\"\n[311] \"723\"  \"5287\" \"3739\" \"1658\" \"76\"   \"1604\" \"149\"  \"554\"  \"349\"  \"639\" \n[321] \"416\"  \"2966\" \"378\"  \"475\"  \"1212\" \"5670\" \"15\"   \"4986\" \"324\"  \"3657\"\n[331] \"5571\" \"881\"  \"322\"  \"1998\" \"3795\" \"5064\" \"232\"  \"5447\" \"2232\" \"5307\"\n[341] \"3578\" \"4645\" \"6277\" \"6483\" \"1028\" \"5649\" \"1493\" \"52\"   \"4329\" \"5765\"\n[351] \"4927\" \"4871\" \"5099\" \"419\"  \"2019\" \"3490\" \"5412\" \"4310\" \"2156\" \"4040\"\n[361] \"4791\" \"6205\" \"1295\" \"4177\" \"2216\" \"6355\" \"4493\" \"4428\" \"3089\" \"2142\"\n[371] \"4354\" \"5650\" \"2801\" \"2977\" \"919\"  \"1951\" \"3641\" \"5697\" \"6452\" \"3271\"\n[381] \"4515\" \"3665\" \"4167\" \"6008\" \"6094\" \"605\"  \"5608\" \"2942\" \"2360\" \"4579\"\n[391] \"4805\" \"239\"  \"612\"  \"4937\" \"3692\" \"4287\" \"2203\" \"1547\" \"5444\" \"872\" \n[401] \"4513\" \"6280\" \"5050\" \"2226\" \"5135\" \"5278\" \"2570\" \"4509\" \"2732\" \"1820\"\n[411] \"5495\" \"1882\" \"789\"  \"4290\" \"1249\" \"3306\" \"5468\" \"2342\" \"2217\" \"1252\"\n[421] \"1828\" \"832\"  \"4529\" \"2750\" \"5511\" \"4111\" \"2200\" \"695\"  \"611\"  \"1916\"\n[431] \"1646\" \"1774\" \"1977\" \"5298\" \"1007\" \"3956\" \"5659\" \"6\"    \"1365\" \"619\" \n[441] \"3131\" \"2941\" \"2027\" \"3838\" \"6039\" \"5624\" \"5323\" \"2730\" \"1783\" \"1579\"\n[451] \"3397\" \"3685\" \"5180\" \"1741\" \"5219\" \"5103\" \"997\"  \"1451\" \"2102\" \"309\" \n[461] \"3508\" \"4429\" \"2320\" \"4943\" \"1236\" \"5285\" \"1622\" \"2865\" \"254\"  \"581\" \n[471] \"4635\" \"198\"  \"5257\" \"5006\" \"2363\" \"922\"  \"399\"  \"3948\" \"2198\" \"5393\"\n[481] \"4609\" \"5299\" \"2598\" \"1214\" \"5875\" \"3626\" \"4087\" \"783\"  \"1482\" \"290\" \n[491] \"5956\" \"3011\" \"2293\" \"6176\" \"3871\" \"5478\" \"1123\" \"319\"  \"2469\" \"4151\"\n[501] \"2395\" \"4073\" \"2072\" \"1762\" \"1775\" \"3325\" \"1560\" \"3769\" \"5755\" \"4011\"\n[511] \"6389\" \"4958\" \"3523\" \"1452\" \"4576\" \"5182\" \"1179\" \"1059\" \"6467\" \"369\" \n[521] \"5795\" \"1836\" \"1684\" \"1737\" \"988\"  \"5853\" \"1201\" \"866\"  \"110\"  \"775\" \n[531] \"5303\" \"1938\" \"1283\" \"5636\" \"1474\" \"3236\" \"2262\" \"2881\" \"892\"  \"2032\"\n[541] \"129\"  \"6375\" \"1044\" \"540\"  \"3219\" \"3183\" \"1895\" \"2631\" \"1354\" \"655\" \n[551] \"4963\" \"3040\" \"4729\" \"6286\" \"5823\" \"4224\" \"729\"  \"719\"  \"5217\" \"3569\"\n[561] \"1447\" \"1394\" \"4794\" \"1664\" \"501\"  \"3668\" \"3098\" \"1080\" \"2266\" \"186\" \n[571] \"5841\" \"3375\" \"1111\" \"430\"  \"677\"  \"3973\" \"6471\" \"1021\" \"3674\" \"6203\"\n[581] \"2762\" \"572\"  \"5960\" \"970\"  \"460\"  \"4630\" \"5655\" \"5365\" \"2020\" \"3275\"\n[591] \"5150\" \"3265\" \"3328\" \"3925\" \"1265\" \"768\"  \"670\"  \"1156\" \"2275\" \"974\" \n\n\nLa commande str() affiche quand à elle d’autres informations concernant les données. En particulier, on retrouve le type (data.frame) et la dimension (nombres d’observations et de variables) des données. En outre, pour chaque variable, on peut lire son nom, son format (entier, numérique, caractère) ainsi que ses premières valeurs.\n\nstr(Data)\n\n'data.frame':   600 obs. of  8 variables:\n $ Qualite : chr  \"medium\" \"medium\" \"medium\" \"medium\" ...\n $ Type    : int  1 0 0 0 0 1 0 0 0 0 ...\n $ AcidVol : num  0.62 0.34 0.22 0.35 0.42 0.48 0.21 0.28 0.3 0.4 ...\n $ AcidCitr: num  0.01 0.1 0.22 0.46 0.32 0.32 0.32 0.14 0.25 0.42 ...\n $ SO2lbr  : num  8 17 39 61 20 21 39 64 21 41 ...\n $ SO2tot  : int  46 63 110 183 167 122 113 159 124 176 ...\n $ Densite : num  0.993 0.994 0.999 0.998 0.995 ...\n $ Alcool  : num  11.8 9.2 9 9 10.6 9.4 10.2 10 10.8 9.4 ...\n\n\nOn voit ici que les variables sont de différentes natures :\n\nLes variables Qualite et Type sont des variables qualitatives\nLes autres variables sont quantitatives\n\nAttention à bien préciser à R les variables qui doivent être considérées comme qualitatives. Ici, on change donc la nature des variables Qualite et Type:\n\nData$Qualite=as.factor(Data$Qualite)\nData$Type=factor(Data$Type,labels=c(\"blanc\",\"rouge\"))\nhead(Data)\n\n     Qualite  Type AcidVol AcidCitr SO2lbr SO2tot Densite Alcool\n1352  medium rouge    0.62     0.01      8     46 0.99332   11.8\n5493  medium blanc    0.34     0.10     17     63 0.99370    9.2\n5153  medium blanc    0.22     0.22     39    110 0.99855    9.0\n5308  medium blanc    0.35     0.46     61    183 0.99786    9.0\n3866  medium blanc    0.42     0.32     20    167 0.99479   10.6\n694   medium rouge    0.48     0.32     21    122 0.99840    9.4\n\n\nOn peut obtenir un résumé rapide du jeu de données à l’aide de la fonction summary()\n\nsummary(Data)\n\n   Qualite       Type        AcidVol          AcidCitr          SO2lbr      \n bad   : 19   blanc:425   Min.   :0.1000   Min.   :0.0000   Min.   :  2.00  \n good  :110   rouge:175   1st Qu.:0.2400   1st Qu.:0.2400   1st Qu.: 15.75  \n medium:471               Median :0.3000   Median :0.3000   Median : 27.00  \n                          Mean   :0.3512   Mean   :0.3141   Mean   : 29.41  \n                          3rd Qu.:0.4300   3rd Qu.:0.3900   3rd Qu.: 41.00  \n                          Max.   :1.0400   Max.   :1.0000   Max.   :112.00  \n     SO2tot         Densite           Alcool     \n Min.   :  7.0   Min.   :0.9875   Min.   : 8.00  \n 1st Qu.: 68.0   1st Qu.:0.9925   1st Qu.: 9.50  \n Median :114.5   Median :0.9949   Median :10.40  \n Mean   :111.2   Mean   :0.9947   Mean   :10.49  \n 3rd Qu.:154.0   3rd Qu.:0.9970   3rd Qu.:11.30  \n Max.   :278.0   Max.   :1.0030   Max.   :14.00"
  },
  {
    "objectID": "TP2-Stat.html#statistiques-descriptives-unidimensionnelles",
    "href": "TP2-Stat.html#statistiques-descriptives-unidimensionnelles",
    "title": "TP2 - Statistique avec R",
    "section": "1.2 Statistiques descriptives unidimensionnelles",
    "text": "1.2 Statistiques descriptives unidimensionnelles\n\n1.2.1 Variable qualitative\nOn considère ici une variable qualitative \\(X\\) dont on observe \\(n\\) réalisations \\(\\underline{x}=(x_1,x_2,\\ldots,x_n)\\). Cette variable prend \\(K\\) modalités \\(m_1,\\ldots,m_K\\). Si les modalités n’ont pas d’ordre naturel, on parle de variable qualitative nominale (ex. Type), sinon c’est une variable qualitative ordinale (ex. Qualite).\nLa variable Type contient \\(K=\\) 2 modalités qui sont blanc, rouge.\n\nlevels(Data$Type)\n\n[1] \"blanc\" \"rouge\"\n\n\nOn récupère l’effectif \\(n_k=\\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i=m_k}\\) pour chaque modalité \\(m_k\\) avec summary() ou table().\n\nsummary(Data$Type)\n\nblanc rouge \n  425   175 \n\nEffType = as.vector(table(Data$Type))\nEffType\n\n[1] 425 175\n\n\nOn utilise aussi les fréquences \\(f_k=\\frac{n_k}{n}\\) donc \\(\\underset{k=1}{\\stackrel{K}{\\sum}} f_k=1\\).\n\n\n\nDescription de la variable Type\n\n\nmodalite\nEff\nFreq\n\n\n\n\nblanc\n425\n0.708\n\n\nrouge\n175\n0.292\n\n\n\n\n\nPour une variable qualitative ordinale, on utilise également les effectifs cumulés \\(N_k=\\underset{\\ell=1}{\\stackrel{k}{\\sum}} n_\\ell\\) et les fréquences cumulées \\(F_k=\\underset{\\ell=1}{\\stackrel{k}{\\sum}} f_\\ell\\).\nPour une variable qualitative, on utilise la représentation par camembert (pie) ou diagramme en bâton (barplot)\n\n\n\n\n\nPour une variable qualitative ordinale, on peut également tracer les fréquences cumulées :\n\n\n\n\n\n\n\n1.2.2 Variable quantitative\nNous allons ici nous intéresser à l’étude d’une variable quantitative \\(X\\) dont on a \\(n\\) observations \\(\\underline{x}=(x_1,\\ldots,x_n)\\). On va illustrer cette section avec la variable Alcool. Vous pouvez reprendre l’étude pour les autres variables quantitatives du jeu de données.\n\n1.2.2.1 Indices statistiques\nNous rappelons les principaux indicateurs statistiques que l’on peut évaluer pour une série de mesures \\(\\underline{x}\\) : la moyenne, la médiane, la variance, l’écart-type ….\n\nMean/var/sdmin/max/rangemédiane / quartiles / quantiles\n\n\nLa moyenne de \\(\\underline{x}\\) : \\(\\bar{x} = \\displaystyle\\frac{1}{n} \\underset{i=1}{\\stackrel{n}{\\sum}} x_i\\)\n\nmean(Data$Alcool)\n\n[1] 10.48592\n\n\nLa variance \\(s_x^2 = \\displaystyle\\frac{1}{n}\\underset{i=1}{\\stackrel{n}{\\sum}} (x_i - \\bar{x})^2\\), la variance corrigée \\(var(\\underline{x})=\\displaystyle\\frac{1}{n-1}\\underset{i=1}{\\stackrel{n}{\\sum}} (x_i - \\bar{x})^2\\) et l’écart-type corrigé \\(\\sqrt{var(\\underline{x})}\\). Attention les fonctions var() et sd() renvoient les valeurs corrigées de la variance et de l’écart-type respectivement.\n\nvar(Data$Alcool)\n\n[1] 1.316059\n\nsd(Data$Alcool)\n\n[1] 1.147196\n\n\n\n\nLa commande range() renvoie respectivement le minimum et le maximum. On peut aussi utiliser min()et max().\n\nrange(Data$Alcool)\n\n[1]  8 14\n\nmin(Data$Alcool)\n\n[1] 8\n\nmax(Data$Alcool)\n\n[1] 14\n\n\nOn peut alors récupérer l’étendue (\\(\\textrm{max}(\\underline{x}) - \\textrm{min}(\\underline{x})\\) ) avec le code suivant :\n\ndiff(range(Data$Alcool))\n\n[1] 6\n\n\n\n\nLa médiane est une valeur qui divise l’échantillon en deux sous-échantillons de même cardinal : \\(\\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i\\geq m} \\geq \\frac{n}{2} \\textrm{ et } \\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i\\leq m} \\geq \\frac{n}{2}\\).\n\nmedian(Data$Alcool)\n\n[1] 10.4\n\nsort(Data$Alcool)[296:305]\n\n [1] 10.3 10.3 10.3 10.3 10.4 10.4 10.4 10.4 10.4 10.4\n\n\nLa médiane est le deuxième des trois quartiles :\n\nle premier quartile \\(q_{0.25}\\) est une valeur qui sépare les 25\\(\\%\\) des valeurs inférieures de l’échantillon du reste\nle deuxième quartile \\(q_{0.5}\\) est la médiane\nle troisième quartile \\(q_{0.75}\\) est une valeur qui sépare les 25% des valeurs supérieures de l’échantillon du reste. On retrouve ces valeurs dans la représentation par boxplot (voir plus bas).\n\nLes quartiles sont des cas particuliers de la notion de quantile. Le \\(\\alpha\\)-quantile empirique est défini par \\(q_{\\alpha} = x_{(i)}\\) avec \\(\\alpha\\in]\\frac{i-1}{n}, \\frac{i}{n}]\\) où \\(x_{(1)}\\leq x_{(2)}\\leq \\ldots \\leq x_{(n)}\\) sont les valeurs ordonnées de la série statistique.\n\nquantile(Data$Alcool)\n\n  0%  25%  50%  75% 100% \n 8.0  9.5 10.4 11.3 14.0 \n\nquantile(Data$Alcool,0.9)\n\n 90% \n12.1 \n\n\nPour calculer l’écart interquantile, il suffit de faire la différence entre les troisième et premier quantiles, à savoir\n\nq.Alc &lt;- quantile(x = Data$Alcool, probs=c(.25,.75), names=FALSE)\ndiff(q.Alc)\n\n[1] 1.8\n\n\net les valeurs d’adjacence sont obtenues de la manière suivante :\n\nL=q.Alc + diff(q.Alc) * c(-1.5,1.5) ; L\n\n[1]  6.8 14.0\n\n# valeur adjacente inférieure :\nmin(Data$Alcool[Data$Alcool&gt;=L[1]])\n\n[1] 8\n\n# valeur adjacente supérieure :\nmax(Data$Alcool[Data$Alcool&lt;=L[2]])\n\n[1] 14\n\n\nPar ailleurs, toutes ces informations sont stockées dans la commande summary() :\n\nsummary(Data$Alcool)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   8.00    9.50   10.40   10.49   11.30   14.00 \n\n\noù sont affichés respectivement le minimum, le premier quartile, la médiane, la moyenne, le troisième quartile et le maximum.\n\n\n\n\n\n1.2.2.2 Représentations graphiques\n\nHistogrammeFonction de répartition empiriqueBoîte à moustaches / boxplot\n\n\nL’histogramme est une représentation graphique qui permet de visualiser la répartition d’une variable quantitative. Les valeurs sont regroupées en intervalles \\(]a_k,a_{k+1}[\\) et la hauteur associée est \\(h_k=\\frac{f_k}{a_{k+1} - a_k}\\).\n\ng1&lt;-ggplot(Data,aes(x=Alcool))+\n  geom_histogram(bins=15,color=\"black\", fill=\"white\")+\n  ggtitle(\"Histo. des effectifs\")+\n  ylab(\"Frequency\")+xlab(\"Alcool\")\ng2&lt;-ggplot(Data,aes(x=Alcool))+\n  geom_histogram(aes(y=..density..),bins=15,color=\"black\", fill=\"white\")+\n  ggtitle(\"Histo. des fréquences\")+\n  ylab(\"Density\")+xlab(\"Alcool\")\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\n\n\nLa fonction de répartition empirique est la fonction en escalier définie par \\(t\\in\\mathbb{R}\\mapsto F_n(t) = \\displaystyle\\frac{1}{n} \\underset{i=1}{\\stackrel{n}{\\sum}} \\mathbb{1}_{x_i\\leq t}\\)\n\nggplot(Data, aes(Alcool)) + \n  stat_ecdf(geom = \"step\")+xlab(\"Variable Alcool\")+\n  ylab(\"\")+ggtitle(\"Fonction de répartition empirique\")+\n  geom_hline(yintercept=0, linetype=\"dashed\")+geom_hline(yintercept=1, linetype=\"dashed\")\n\n\n\n\n\n\nLa boîte à moustaches est un graphique qui résume la série statistique à partir de ses valeurs extrêmes et ses quartiles. En effet, on retrouve sur cette représentation\n\nles quartiles\nla valeur adjacente supérieure \\(v+\\), qui est la plus grande valeur de l’échantillon inférieure ou égale à \\(L+ = q_{0.75} + 1.5 (q _{0.75} − q_{0.25})\\)\nla valeur adjacente inférieure \\(v−\\), qui est la plus petite valeur de l’échantillon supérieure ou égale à \\(L− = q_{0.25} − 1.5 (q_{0.75} − q_{0.25})\\)\nles valeurs extrêmes (outliers) qui sont les valeurs de l’échantillon n’appartenant pas à l’intervalle \\([v−, v+]\\).\n\nVoici les boxplots pour les variables quantitatives de notre exemple.\n\nlibrary(reshape2)\nggplot(melt(Data[,-c(1,2)]),aes(x=variable,y=value))+\n  geom_boxplot()\n\n\n\n\nNous allons pour la suite nous concentrer sur la variable SO2lbr. En plus du graphique, on peut récupérer de la fonction boxplot() différentes informations :\n\nB &lt;- boxplot(Data$SO2lbr,horizontal=TRUE)\n\n\n\nattributes(B)\n\n$names\n[1] \"stats\" \"n\"     \"conf\"  \"out\"   \"group\" \"names\"\n\n\nDans B$stats, on retrouve les quartiles, la médiane et les valeurs adjacentes :\n\nB$stats\n\n     [,1]\n[1,]  2.0\n[2,] 15.5\n[3,] 27.0\n[4,] 41.0\n[5,] 73.5\n\nmedian(Data$SO2lbr)\n\n[1] 27\n\nq &lt;- quantile(x = Data$SO2lbr, probs=c(.25,.75), names=FALSE)\nq\n\n[1] 15.75 41.00\n\nL=q + diff(q) * c(-1.5,1.5) \nmin(Data$SO2lbr[Data$SO2lbr&gt;=L[1]])\n\n[1] 2\n\nmax(Data$SO2lbr[Data$SO2lbr&lt;=L[2]])\n\n[1] 73.5\n\n\nDans B$out renvoie toutes les valeurs aberrantes (en dehors des barres inférieure et supérieure c’est à dire en dehors de l’intervalle \\([v-,v+]\\)):\n\nB$out\n\n[1]  89.0 105.0  85.0 112.0  79.5\n\nData$SO2lbr[which(Data$SO2lbr&lt;B$stats[1] | Data$SO2lbr&gt;B$stats[5])]\n\n[1]  89.0 105.0  85.0 112.0  79.5"
  },
  {
    "objectID": "TP2-Stat.html#statistiques-descriptives-bidimensionnelles",
    "href": "TP2-Stat.html#statistiques-descriptives-bidimensionnelles",
    "title": "TP2 - Statistique avec R",
    "section": "1.3 Statistiques descriptives bidimensionnelles",
    "text": "1.3 Statistiques descriptives bidimensionnelles\n\n1.3.1 Entre 2 variables quantitatives\nSupposons dans cette partie que X et Y sont deux variables quantitatives et on observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\).\nOn peut tout d’abord représenter le nuage de points de coordonnées \\((x_i,y_i)\\) :\n\nggplot(Data,aes(x=Alcool,y=Densite))+\n  geom_point()\n\n\n\n\n\n1.3.1.1 Corrélation\nOn peut calculer la covariance (généralisaton bidimensionnelle de la variance) entre ces deux séries de mesure à l’aide de la commande cov(): \\[\nCov(\\underline{x},\\underline{y}) = \\frac{1}{n} \\sum_{i=1}^n (x_i-\\bar{x}) (y_i -\\bar{y}).\n\\] Mais la covariance dépendant des unités de mesure des deux variables considérées, on calcule plutôt la corrélation linéaire (renormalisation de la covariance par les écarts-type) qui appartient à l’intervalle \\([-1,1]\\) à l’aide de cor(): \\[\ncor(\\underline{x},\\underline{y}) = \\frac{Cov(\\underline{x},\\underline{y})}{\\sqrt{s_x^2\\ \\ s_y^2}}\n\\]\nA l’aide de la fonction corrplot() (issue du package du même nom) on représente ici la matrice des corrélations entre les variables quantitatives de notre jeu de données:\n\ncorrplot(cor(Data[,-c(1:2)]),method=\"ellipse\")\n\n\n\n\n\n\n1.3.1.2 Régression linéaire\nLe coefficient de corrélation linéaire entre les variables Densité et Alcool vaut -0.68. On peut vérifier que le nuage de points de ces deux variables s’aligner sur une droite de pente négative :\n\nggplot(Data,aes(x=Alcool,y=Densite))+\n  geom_point()+\n  geom_smooth(method=lm, se=FALSE)\n\n\n\n\n\n\n\n1.3.2 Entre une variable quantitative et une variable qualitative\nSupposons dans cette partie que \\(X\\) est une variable qualitative prenant \\(J\\) modalités \\(m_1, \\ldots, m_J\\) et \\(Y\\) une variable quantitative. On observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\).\nOn note \\(C_j=\\{i\\in\\{1,\\ldots,n\\}; x_i=m_j\\}\\) l’ensemble des individus prenant la modalité \\(m_j\\) et \\(n_j\\) son cardinal.\nLa moyenne de \\(\\underline{y}\\) peut alors se décomposer en une moyenne pondérée des moyennes de \\(y\\) conditionnellement aux modalités de \\(X\\) : \\[\n\\bar{y} = \\frac{1}{n} \\sum_{j=1}^J n_j\\ \\bar{y}_{[j]} \\textrm{   avec   } \\bar{y}_{[j]} = \\frac{1}{n_j} \\sum_{i\\in C_j} y_i\n\\] De même la variance se décompose en \\(s_y^2 = \\underbrace{s_{y,E}^2}_{\\textrm{variance inter-classe}} + \\underbrace{s_{y,R}^2}_{\\textrm{variance intra-classe}}\\) avec\n\\[\ns_{y,E}^2 = \\frac{1}{n} \\sum_{j=1}^J n_j\\ (\\bar{y}_{[j]} - \\bar{y})^2\n\\] et \\[\ns_{y,R}^2 = \\frac{1}{n} \\sum_{j=1}^J n_j\\ s_{y,[j]}^2 \\textrm{ avec } s^2_{y,[j]} = \\frac{1}{n_j}\\sum_{i\\in C_j} (y_i - \\bar{y}_{[j]})^2\n\\] On peut alors définir le rapport de corrélation \\[\n\\rho_{y|x} = \\sqrt{\\frac{s_{y,E}^2}{s_{y}^2}} = \\sqrt{1 - \\frac{s_{y,R}^2}{s_{y}^2}}\\in[0,1].\n\\] Plus \\(\\rho_{y|x}\\) est proche de \\(0\\), plus \\(s_{y,E}^2\\) est proche de 0 et donc moins la variable qualitative \\(X\\) a d’influence sur la variable quantitative \\(Y\\).\nGraphiquement, on peut représenter la distribution de la variable quantitative conditionnellement aux modalités de la variable qualitative pour visualiser la liaison potentielle entre les deux variables.\n\ng1&lt;-ggplot(Data,aes(x=Qualite,y=Alcool))+\n  geom_boxplot()\ng2&lt;-ggplot(Data,aes(x=Type,y=Alcool))+\n  geom_boxplot()\ngrid.arrange(g1,g2,ncol=2)\n\n\n\n\n\n\n1.3.3 Entre deux variables qualitatives\nSupposons dans cette partie que \\(X\\) est une variable qualitative prenant \\(J\\) modalités \\(m_1,\\ldots,m_J\\) et \\(Y\\) est une vraiable qualitative prenant \\(K\\) modalités \\(\\ell_1,\\ldots,\\ell_K\\). On observe une série de \\(n\\) valeurs pour chacune : \\(\\underline{x}=(x_1,\\ldots,x_n)\\) et \\(\\underline{y}=(y_1,\\ldots,y_n)\\). Pour étudier l’influence de deux variables qualitatives entre elles, on se base sur la table de contingence qui est l’ensemble des effectifs conjoints \\[\nn_{j,k} = \\sum_{i=1}^n \\mathrm{1}_{x_i = m_j\\ \\cap\\ y_i=\\ell_k},\\ \\ \\forall j\\in\\{1,\\ldots,J\\},\\ \\forall k\\in\\{1,\\ldots,K\\}\n\\] On définit les effectifs marginaux par \\[\nn_{j,.}=\\sum_{k=1}^K n_{j,k}\\ \\ \\ \\textrm{   et   } \\ \\ \\ n_{.,k}=\\sum_{j=1}^J n_{j,k}\n\\]\n\ntable.cont = table(Data$Qualite,Data$Type)\ntable.cont\n\n        \n         blanc rouge\n  bad       17     2\n  good      89    21\n  medium   319   152\n\n\nGraphiquement, on peut représenter un mosaiplot qui correspond à la représentation des profils-lignes \\[\n\\left(\\frac{n_{j,1}}{n_{j,.}},\\ldots,\\frac{n_{j,K}}{n_{j,.}}\\right)\\in [0,1]^K\n\\] ou des profils-colonnes\n\\[\n\\left(\\frac{n_{1,k}}{n_{.,k}},\\ldots,\\frac{n_{J,k}}{n_{.,k}}\\right)\\in [0,1]^J\n\\]\n\nmosaicplot(table(Data$Qualite,Data$Type))\n\n\n\nmosaicplot(table(Data$Type,Data$Qualite))"
  },
  {
    "objectID": "TP2-Stat.html#estimateurs-pour-m-et-sigma2",
    "href": "TP2-Stat.html#estimateurs-pour-m-et-sigma2",
    "title": "TP2 - Statistique avec R",
    "section": "2.1 Estimateurs pour \\(m\\) et \\(\\sigma^2\\)",
    "text": "2.1 Estimateurs pour \\(m\\) et \\(\\sigma^2\\)\nPour plusieurs valeurs de \\(n\\) :\n\nsimulez un \\(n\\)-échantillon observé \\(\\underline{x}\\) de \\(\\underline{X}\\) de loi \\(\\mathcal{N}(m,\\sigma^2)\\) avec \\(m=5\\) et \\(\\sigma^2=4\\) à l’aide de la fonction rnorm().\nA partir de \\(\\underline{x}\\), donnez une estimation pour le paramètre de moyenne \\(m\\) et pour le paramètre de variance \\(\\sigma^2\\).\nQue constatez-vous ?\n\n\n# A COMPLETER\nn=seq(100,10000,100)\nmest=NULL\nsigma2est=NULL\nfor (i in 1:length(n)){\n  x =   ....                  # echantillon à simuler\n  mest = c(mest, ....)    # estimation de m\n  sigma2est=c(sigma2est, ...)  # estimation de sigma2\n}\n\nValeurs obtenues pour l’estimation de \\(m\\) :\n\ndf=data.frame(n=n,mest=mest,sigma2est=sigma2est)\nggplot(df,aes(x=n,y=mest))+\n  geom_point()+\n  geom_hline(yintercept=5, color=\"red\")\n\nValeurs obtenues pour l’estimation de \\(\\sigma^2\\) :\n\nggplot(df,aes(x=n,y=sigma2est))+\n  geom_point()+\n  geom_hline(yintercept=4, color=\"red\")"
  },
  {
    "objectID": "TP2-Stat.html#intervalle-de-confiance-pour-la-moyenne-m",
    "href": "TP2-Stat.html#intervalle-de-confiance-pour-la-moyenne-m",
    "title": "TP2 - Statistique avec R",
    "section": "2.2 Intervalle de confiance pour la moyenne \\(m\\)",
    "text": "2.2 Intervalle de confiance pour la moyenne \\(m\\)\n\n2.2.1 Cas de la variance connue\nNous allons tout d’abord nous intéresser à la construction d’un intervalle de confiance pour \\(m\\) lorsque la variance \\(\\sigma^2\\) est connue, dont la formule est rappelée ici \\[\nIC_{1-\\alpha}(m) = \\left[\\bar X_n \\pm z_{1-\\frac{\\alpha}{2}} \\sqrt{\\frac{\\sigma^2}{n}}\\right]\n\\] où \\(z_{1-\\frac{\\alpha}{2}}\\) est le \\(1-\\frac{\\alpha}{2}\\)-quantile de la loi normale centrée réduite.\nReportez-vous aux slides de remise à niveau pour vous rappeler la construction.\n\nEcrivez une fonction int.conf.moy1 calculant \\(IC\\) au niveau de confiance niv.conf à partir d’un échantillon observé \\(\\underline{x}\\) et de la valeur de la variance sigma2\n\n\n# A COMPLETER\n\nint.conf.moy1 &lt;- function(x,niv.conf,sigma2){\n  alpha = 1-niv.conf\n  IC = ... + c(-1,1) * qnorm(1-alpha/2) * ...\n  return(IC)\n}\n\n\nEtudiez le comportement de l’intervalle de confiance en fonction de \\(n\\) et du niveau de confiance sur données simulées. Pour cela, pour différentes valeurs de \\(n\\) et niv.conf,\n\n\nsimulez un échantillon \\(x\\) de taille \\(n\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ndéduisez-en un intervalle de confiance pour \\(m\\) au niveau de confiance niv.conf à l’aide de la fonction int.conf.moy1 programmée précédemment\n\n\nn= c(...)\nniv.conf = c(....)\nfor (i in 1:length(n)){\n  for (j in 1:length(niv.conf)){\n    x= ...\n    IC=int.conf.moy1(....)\n    print(paste(\"n= \", n[i],\", niv.conf= \",niv.conf[j],\" : IC vaut [\", round(IC[1],3),\",\",round(IC[2],3),\"], il est de longueur\",round(IC[2]-IC[1],3), sep=\"\"))\n  }\n}\n\n\nNous allons ici illustrer le fait que la proportion moyenne de fois où le paramètre \\(m\\) appartient à l’intervalle de confiance vaut niv.conf.\n\nPour cela, répétez \\(K\\) fois l’expérience suivante\n\nsimulez un échantillon \\(x\\) de taille \\(n=1000\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ndéduisez-en un intervalle de confiance pour \\(m\\) au niveau de confiance niv.conf=0.95 à l’aide de la fonction int.conf.moy1 programmée précédemment\ncomptabilisez si la vraie valeur de \\(m\\) appartient à l’intervalle de confiance ou pas\n\n\npropconf &lt;- function(K,m){\nnb.app=0  \nfor (k in 1:K){\n  x= ...\n  IC=int.conf.moy1(....)\n  nb.app = nb.app + (m&gt;=IC[1]) * (m&lt;=IC[2])\n}\nreturn(nb.app/K)\n}  \n\nEvaluez plusieurs fois pour \\(K\\) valant \\(100\\) et \\(1000\\). Qu’observez-vous ?\nCommentaire : …..\n\n\n2.2.2 Cas de la variance inconnue\nNous allons maintenant nous intéresser à la construction d’un intervalle de confiance pour \\(m\\) lorsque la variance \\(\\sigma^2\\) est inconnue, dont la formule est rappelée ici \\[\nIC_{1-\\alpha}(m) = \\left[\\bar X_n \\pm t_{1-\\frac{\\alpha}{2}} \\sqrt{\\frac{S^2}{n}}\\right]\n\\] où \\(t_{1-\\frac{\\alpha}{2}}\\) est le \\(1-\\frac{\\alpha}{2}\\)-quantile de la loi de Student à \\(n-1\\) degrés de liberté et \\(S^2\\) est l’estimateur de la variance.\nReportez-vous aux slides de remise à niveau pour vous rappeler la construction.\n\nEcrivez une fonction int.conf.moy2 calculant \\(IC\\) au niveau de confiance niv.conf à partir d’un échantillon observé \\(\\underline{x}\\).\n\n\n# A COMPLETER\nint.conf.moy2 &lt;- function(x,niv.conf){\n  alpha = 1-niv.conf\n  S2 =     # estimateur de la variance\n  IC = ... + c(-1,1) * qt(1-alpha/2,length(x)-1) * ...\n  return(IC)\n}\n\n\nEtudiez le comportement de l’intervalle de confiance en fonction de \\(n\\) et du niveau de confiance sur données simulées. Pour cela, pour différentes valeurs de \\(n\\) et niv.conf,\n\n\nsimulez un échantillon \\(x\\) de taille \\(n\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ndéduisez-en un intervalle de confiance pour \\(m\\) au niveau de confiance niv.conf à l’aide de la fonction int.conf.moy2 programmée précédemment\n\n\nn= c(...)\nniv.conf = c(....)\nfor (i in 1:length(n)){\n  for (j in 1:length(niv.conf)){\n    x= ...\n    IC=int.conf.moy2(....)\n   print(paste(\"n= \", n[i],\", niv.conf= \",niv.conf[j],\" : IC vaut [\", round(IC[1],3),\",\",round(IC[2],3),\"], il est de longueur\",round(IC[2]-IC[1],3), sep=\"\"))\n  }\n}\n\n\nComparez sur données simulées les intervalles de confiance obtenus dans le cas de la variance connue (int.conf.moy1), le cas de la variance inconnue (int.conf.moy2) et avec la fonction t.test()de R.\n\n\nx = .... # Echantillon simulé\nint.conf.moy1(x,niv.conf=0.95,sigma2= )\nint.conf.moy2(x,niv.conf=0.95)\nt.test(x,conf.level=0.95)"
  },
  {
    "objectID": "TP2-Stat.html#test-sur-la-moyenne",
    "href": "TP2-Stat.html#test-sur-la-moyenne",
    "title": "TP2 - Statistique avec R",
    "section": "2.3 Test sur la moyenne",
    "text": "2.3 Test sur la moyenne\nConsidérons \\(X_1,\\ldots,X_n\\) des variables aléatoires i.i.d. de loi \\(\\mathcal{N}(m,\\sigma^2)\\) (où \\(m\\) est inconnue) et soit \\(m_0 \\in \\mathbb{R}\\) donnée.\n\n2.3.1 Cas de la variance connue\n\nDans les trois tests suivants au niveau \\(\\alpha\\),\n\n\nTest 1 : \\(\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1^+ : m&gt; m_0\\)\nTest 2 : \\(\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1^{-} : m&lt; m_0\\)\nTest 3 : \\(\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1 : m\\neq m_0\\)\n\nprécisez\n\nla statistique de test et sa loi sous \\(\\mathcal{H}_0\\)\nla forme de la zone de rejet\nl’expression de la pvaleur en fonction de \\(\\phi\\) qui désigne la fonction de répartition d’une \\(\\mathcal{N}(0,1)\\)\n\n\nComplétez la fonction suivante test.moy1() qui évalue la p-valeur du test \\(\\mathcal{H}_0 : m=m_0\\) contre l’alternative\n\n\ntwo.sided pour le test bilatéral avec \\(\\mathcal{H}_1 : m\\neq m_0\\)\ngreaterpour le test unilatéral avec \\(\\mathcal{H}_1 : m&gt; m_0\\)\nlesspour le test unilatéral avec \\(\\mathcal{H}_1 : m &lt; m_0\\)\n\nà partir d’un échantillon observé \\(\\underline{x}\\) (supposé gaussien) et la valeur de la variance \\(\\sigma^2\\). Vous pourrez vous aider de la fonction pnorm().\n\ntest.moy1 &lt;- function(x,sigma2,m0,alternative=\"greater\"){\n  Zn.obs = sqrt(length(x))*(mean(x)-m0)/sqrt(sigma2)\n  if(alternative==\"two.sided\"){      \n      pval = ... # A COMPLETER \n  }else{\n      if(alternative==\"greater\"){      \n        pval = ... # A COMPLETER \n      }else{\n        if(alternative==\"less\"){       \n          pval = ... # A COMPLETER \n        }\n      }\n    }\nreturn(pval)\n}\n\n\nAfin d’estimer la taille du test, complétez la fonction estim.prop.test.moy1() qui estime la proportion moyenne de fois où le test rejette l’hypothèse nulle \\(\\mathcal{H_0}\\). Pour cela, répétez \\(K\\) fois l’expérience suivante\n\n\nsimulez un échantillon \\(x\\) de taille \\(n=1000\\) de v.a. gaussiennes de moyenne \\(m=5\\) et de variance \\(\\sigma^2=4\\) à l’aide de la fonction rnorm()\ncalculez la p-valeur obtenue avec la fonction test.moy1 programmée précédemment pour le test \\(\\mathcal{H}_0: m=5\\) contre \\(\\mathcal{H}_1^+: m&gt;5\\).\n\ncomptabilisez si l’hypothèse nulle est rejetée au niveau \\(\\alpha = 5\\%\\).\n\n\nestim.prop.test.moy1 &lt;-function(n=1000,m=5,sigma2=4,m0=5,alpha=0.05,K=100,alternative=\"greater\"){\n  nb.rejets=0\n  for(k in 1:K){\n      x = ... # echantillon simule\n      pval = ... # en utilisant test.moy1\n      nb.rejets = nb.rejets + ... # A COMPLETER \n  }\nreturn(nb.rejets/K)\n}\n\nQu’observez-vous ? Répétez cette étape plusieurs fois pour \\(K=100\\) et \\(K=1000\\), que remarquez-vous ?\n\nEtude de la puissance du test \\(\\mathcal{H}_0: m=m_0\\) contre \\(\\mathcal{H}_1^+: m&gt;m_0\\)\n\n\nMontrez que la puissance théorique du test est donnée par l’expression suivante \\[\n\\Pi: \\theta\\in ]m_0,+\\infty[ \\mapsto 1 - \\Phi\\left(z_{1-\\alpha} - \\sqrt{n}\\ \\frac{\\theta - m_0}{\\sigma}\\right)\n\\] où \\(z_{1-\\alpha}\\) est le (1-)-quantile de la loi normale \\(\\mathcal{N}(0,1)\\) et \\(\\Phi\\) est la fonction de répartition de la loi normale \\(\\mathcal{N}(0,1)\\).\n\nCréez une fonction puiss.test.moy.1() pour calculer cette fonction puissance.\n\npuiss.test.moy.1 &lt;- function(n=1000,sigma2=4,m0=5,alpha=0.05,mmax){\n  theta = seq(m0,mmax,0.01)\n  puiss = ....\n  return(puiss)\n}\n\nA l’aide de la fonction puiss.test.moy.1(), tracez sur un même graphique la fonction puissance en faisant varier le niveau \\(\\alpha\\) du test (\\(1\\%\\), \\(5\\%\\), \\(10\\%\\)) et commentez.\n\n# A COMPLETER\n\nA l’aide de la fonction puiss.test.moy.1(), tracez sur un même graphique la fonction puissance en faisant varier la taille de l’échantillon \\(n\\) et commentez.\n\n# A COMPLETER\n\n\n\n2.3.2 Cas de la variance inconnue\nOn suppose maintenant que la variance \\(\\sigma^2\\) est inconnue et on s’intéresse uniquement au Test 1 \\[\n\\mathcal{H}_0 : m=m_0 \\quad \\quad \\mbox{contre} \\quad \\quad \\mathcal{H}_1^+ : m&gt; m_0\n\\] 1. Rappelez la statistique de test, la loi sous \\(\\mathcal{H}_0\\) et la forme de la zone de rejet pour le test 1 quand la variance est inconnue\n\nConstruisez une fonction test.moy2() pour évaluer la pvaleur du test à partir d’un échantillon observé \\(\\underline{x}\\). Vous pourrez vous aider de la fonction pt() pour la fonction de répartiion d’une loi de Student.\n\n\ntest.moy2 &lt;- function(x,m0){\n  Tn_obs = # a completer\n  pval =  # a completer, utiliser pt()\n  return(pval)\n}\n\n\nComparez la pvaleur obtenue avec test.moy2() et la sortie de t.test() de R sur des données simulées.\n\n\nx = rnorm(n=1000,mean =5,sd=2)\ntest.moy2(x,m0=5)\nt.test (....) # a completer"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]